#+TITLE: PWS â€“ Sistema di pubblicazione EPrivacy
#+AUTHOR: Emmanuele Somma
#+OPTIONS: toc:nil num:nil

* Introduzione

Questo file Ã¨ il cuore del sistema di pubblicazione PWS (Publishing Workflow System)
per il progetto E-Privacy. Il codice Ã¨ scritto in Emacs Lisp secondo lo stile 
"literate programming", ed Ã¨ suddiviso in sezioni modulari che verranno tanglate
in file distinti nella directory dei sorgenti.

Le funzionalitÃ  principali comprendono:

- Caricamento delle edizioni e metadati da file `vars.org`
- Analisi e stato dei repository Git (`private`, `public`)
- Visualizzazione testuale interattiva della dashboard
- Comandi per attivare/disattivare/modificare documenti
- Navigazione tra edizioni
- Generazione dei file finali (markdown/org/export)

* edoc-vars.el - Parsing dei file vars.org

Questo modulo si occupa di caricare e analizzare il file `vars.org` contenente i metadati
principali dellâ€™edizione corrente. Restituisce un alist o plist con le informazioni estratte.


#+BEGIN_SRC emacs-lisp :tangle edoc-vars.el
;;; edoc-vars.el --- Parsing del file vars.org -*- lexical-binding: t -*-

(require 'org-element)

(setq edoc--synth-rules-vars
      '((:SLUG . (lambda (vars file)
                   (let ((n (plist-get vars :eprivacy_n))
                         (base (file-name-base file)))
                     (format "e-privacy-%s-%s" (or n "ERROR") base))))))


(defun edoc-parse-vars (file)
  "Parsa il file vars.org e restituisce un plist con tutte le keyword #+KEY: e i documenti aggiuntivi."
  (with-temp-buffer
    (insert-file-contents file)
    (org-mode)
    (let* ((parsed (org-element-parse-buffer))
           (vars (edoc--extract-all-keywords parsed))
           (extra-docs (edoc--extract-documents-table parsed)))
      (plist-put vars :extra-documents extra-docs)
      vars)))

(defun edoc--extract-all-keywords (parsed)
  "Estrae tutte le keyword #+KEY: dal buffer Org come plist, lowercase."
  (let (result)
    (org-element-map parsed 'keyword
      (lambda (el)
        (let* ((key (org-element-property :key el))
               (val (string-trim (org-element-property :value el))))
          (setq result (plist-put result (intern (concat ":" (downcase key))) val)))))
    result))

(defun edoc--extract-documents-table (parsed)
  "Estrae la tabella 'Documenti aggiuntivi' dal file e restituisce una lista di alist."
  (let ((tables (org-element-map parsed 'table
                  (lambda (tbl)
                    (let ((title (org-element-property :raw-value
                                                       (org-element-lineage tbl '(headline)))))
                      (when (and title (string-match "Documenti aggiuntivi" title))
                        tbl))))))
    (when tables
      (let* ((table (car tables))
             (rows (org-table-to-lisp
                    (org-element-interpret-data table))))
        ;; Rimuove intestazione
        (let ((header (car rows))
              (body (cdr rows)))
          (mapcar (lambda (row)
                    (cl-pairlis (mapcar #'intern (mapcar #'downcase header)) row))
                  body))))))

(defun edoc--org-vars-to-md-header (vars)
  "Trasforma un plist di variabili in intestazione Markdown `Chiave: Valore`."
  (let* ((alist (edoc--plist-to-alist vars))
         (lines
          (mapcar (lambda (pair)
                    (format "%s: %s"
                            (capitalize (substring (symbol-name (car pair)) 1))
                            (cdr pair)))
                  (sort alist (lambda (a b)
                                (string< (symbol-name (car a)) (symbol-name (car b))))))))
    (concat (string-join lines "\n") "\n\n")))


(defun edoc--read-options-line ()
  "Restituisce tutte le opzioni `#+OPTIONS:` da `options.org` come stringa unica."
  (let* ((path (expand-file-name "options.org" edoc-current-edition-path))
         (lines (when (file-readable-p path)
                  (with-temp-buffer
                    (insert-file-contents path)
                    (goto-char (point-min))
                    (let (results)
                      (while (re-search-forward "^#\\+OPTIONS:\\s-*\\(.*\\)" nil t)
                        (push (match-string 1) results))
                      (string-join (nreverse results) " "))))))
    (or lines "â€”")))


(provide 'edoc-vars)
#+END_SRC


* edoc-git.el - Stato dei repository Git

Questo modulo gestisce il fetch, lo stato dei branch, lâ€™autore e la data dellâ€™ultimo commit,
e il controllo di divergenza tra locale e remoto per i due repository.


#+BEGIN_SRC emacs-lisp :tangle edoc-git.el
;;; edoc-git.el --- Stato Git per PWS -*- lexical-binding: t -*-

(defun edoc-git-last-commit-summary (repo-path)
  "Restituisce un riassunto dellâ€™ultimo commit nel repository in REPO-PATH."
  (when (file-directory-p repo-path)
    (let ((default-directory repo-path))
      (with-temp-buffer
        (call-process "git" nil t nil "log" "-1" "--pretty=format:%an (%ar)")
        (string-trim (buffer-string))))))

(defun edoc-git-up-to-date-p (repo-path)
  "Restituisce t se il repository locale Ã¨ aggiornato rispetto al remoto."
  (when (file-directory-p repo-path)
    (let ((default-directory repo-path))
      (call-process "git" nil nil nil "fetch")
      (with-temp-buffer
        (call-process "git" nil t nil "status" "-uno")
        (goto-char (point-min))
        (not (re-search-forward "Your branch is behind" nil t))))))

(defun edoc-git-repo-dirty-p (repo-path)
  "Restituisce t se il repository contiene modifiche locali non committate."
  (when (file-directory-p repo-path)
    (let ((default-directory repo-path))
      ;; git diff --quiet restituisce 1 se ci sono modifiche
      (= (call-process "git" nil nil nil "diff" "--quiet") 1))))


(provide 'edoc-git)
#+END_SRC

* edoc-dashboard.el - Interfaccia testuale

Responsabile della visualizzazione dellâ€™interfaccia principale: titolo, repo status,
fase corrente, lista documenti, e informazioni evento.

#+BEGIN_SRC emacs-lisp :tangle edoc-dashboard.el
;;; edoc-dashboard.el --- Interfaccia testuale PWS -*- lexical-binding: t -*-

(require 'edoc-vars)
(require 'edoc-git)
(require 'edoc-import)
(require 'edoc-export)
(require 'edoc-org-program)
(require 'edoc)
(require 'transient)


(defun edoc--repo-on-current-line ()
  "Restituisce il nome logico del repo ('private', 'public' o 'sw') in base alla riga del cursore."
  (save-excursion
    (beginning-of-line)
    (cond
     ((looking-at "^db\\b") "private")
     ((looking-at "^site\\b") "public")
     ((looking-at "^sw\\b") "sw")
     (t nil))))

(defun edoc-dashboard-git-do (operation)
  "Esegue una OPERAZIONE (simbolo: push, pull, commit) sul repo determinato dalla riga corrente."
  (interactive)
  (let* ((repo (edoc--repo-on-current-line))
      	 (repo-path (cond
                     ((string= repo "sw") (expand-file-name "~/epub-system"))
                     (repo (edoc--repo-path repo))
                     (t nil)))
      	 (default-directory repo-path))
    (cond
     ((not repo)
      (message "âš  Posizionati sulla riga di un repository (db o site)."))
     ((not (file-directory-p repo-path))
      (message "âš  Il repository '%s' non esiste." repo))
     (t
      (pcase operation
        ('push
         (call-process "git" nil "*edoc-git*" t "push")
         (message "âœ… Push completato per %s" repo))
        ('pull
         (call-process "git" nil "*edoc-git*" t "pull")
         (message "âœ… Pull completato per %s" repo))
        ('commit-push
         (let ((msg (read-string (format "Messaggio di commit per '%s': " repo))))
           (call-process "git" nil "*edoc-git*" t "add" "-A")
           (call-process "git" nil "*edoc-git*" t "commit" "-m" msg)
           (call-process "git" nil "*edoc-git*" t "push")
           (message "âœ… Commit & push completati per %s" repo))))
      (edoc-dashboard-refresh)))))

(defun edoc-dashboard-git-status ()
  "Mostra lo stato del repository corrente (magit o vc-dir) in base alla riga attiva."
  (interactive)
  (let* ((repo (edoc--repo-on-current-line))
      	 (repo-path (cond
                     ((string= repo "sw") (expand-file-name "~/epub-system"))
                     (repo (edoc--repo-path repo))
                     (t nil))))
    (cond
     ((not repo-path)
      (message "âš  Posizionati su una riga di repo (db, site o sw)."))
     ((not (file-directory-p repo-path))
      (message "âš  Repository %s non trovato." repo))
     ((fboundp 'magit-status)
      (magit-status repo-path))
     (t
      (vc-dir repo-path)))))


(defun edoc--org-file-status (filepath)
  "Restituisce il valore della proprietÃ  #+STATUS: in FILEPATH, se esiste."
  (when (file-readable-p filepath)
    (with-temp-buffer        
      (insert-file-contents filepath nil 0 1000) ; solo le prime linee
      (org-mode)
      (goto-char (point-min))
      (if (re-search-forward "^#\\+STATUS:\\s-*\\(.*\\)$" nil t)
          (let ((val (string-trim (match-string 1))))
            (cond
             ((string-match-p "enabled" val) "âœ” enabled")
             ((string-match-p "draft" val)   "âœŽ draft")
             ((string-match-p "disabled" val) "â€“ disattivato")
             (t val)))
        "â€“ (nessun status)"))))

(defun edoc--plist-to-alist (plist)
  "Converte un plist in una alist."
  (let (alist)
    (while plist
      (let ((key (car plist))
            (val (cadr plist)))
        (setq alist (cons (cons key val) alist))
        (setq plist (cddr plist))))
    (nreverse alist)))

(defun edoc-open-public-shell ()
  "Apre una shell interattiva nella directory del repository public."
  (interactive)
  (let ((default-directory (edoc--repo-path "public")))
    (unless (file-directory-p default-directory)
      (user-error "Directory public non trovata: %s" default-directory))
    (shell (generate-new-buffer-name "*Shell: public*"))))

(defvar edoc--first-file-line nil
  "Line of first file in dashboard")

(defun edoc-dashboard-refresh ()
  "Mostra o aggiorna la dashboard."
  (interactive)
  (let* ((edition-path edoc-current-edition-path)
         (vars-path (expand-file-name "vars.org" edition-path))
         (data (edoc-parse-vars vars-path))
         (title (plist-get data :title))
         (num (plist-get data :eprivacy_n))
         (edition (plist-get data :edition))
         (fase (or (plist-get data :fase) "setup"))
         (buf (get-buffer-create "*PWS Dashboard*")))
    
    (with-current-buffer buf
      (read-only-mode -1)
      (erase-buffer)
      (message "Sto leggendo le informazioni relative all'edizione in corso")
      (insert (propertize "PWS E-PRIVACY PS: " 'face '(:height 1.5 :weight bold)))
      (insert " Working on: ")
      (insert (propertize (format "E-PRIVACY %s %s edition" (or num "??") (or edition "??")) 'face '(:height 1.5 :weight bold)))
      (insert (format "[%s] " fase))
      ;; Legge il contenuto di .last nel repo public
      (let* ((public-root (edoc--repo-path "public"))
	     (last-path (expand-file-name ".last" public-root))
	     (last-value (if (file-readable-p last-path)
			     (with-temp-buffer
                               (insert-file-contents last-path)
                               (string-trim (buffer-string)))
			   "void")))
	(insert (format "[%s]" last-value)))
      (when (edoc-devserver-running-p)
	(insert " ðŸ”¥ http://test.winstonsmith.org"))
      (insert "\n\n")
      
      ;; Repo info
      (insert (propertize "ðŸ“ [Situazione dei repository]\n" 'face '(:weight bold)))
      (insert (edoc--dashboard-repo-info "db" (edoc--repo-path "private")))
      (insert (edoc--dashboard-repo-info "site" (edoc--repo-path "public")))
      (insert (edoc--dashboard-repo-info "sw" (edoc--repo-path "sw")))

      (message "")
      
      
      ;; Documenti presenti
      (insert (propertize "\nðŸ“ [Documenti presenti nella directory:]\n" 'face '(:weight bold)))
      (let* ((doc-files (directory-files edition-path t "\\.org$"))
             (sorted-docs (sort doc-files #'string<)))
        (if (null sorted-docs)
            (progn
              (setq edoc--first-file-line nil)
              (insert "   Nessun documento org trovato\n"))
          (let ((max-name-len (apply #'max (mapcar (lambda (f)
                                         		 (length (file-name-nondirectory f)))
                                         		sorted-docs))))
            (insert (format (format "%%-%ds  ðŸ”’  âœ…  ðŸ“  ðŸ“„\n\n" max-name-len)
                            (make-string (+ max-name-len 2) ?-)))
            (setq edoc--first-file-line (line-number-at-pos))
            (dolist (file sorted-docs)
              (let* ((name (file-name-nondirectory file))
                     (status (edoc--org-file-status file))
                     (start (point)))
                (let* ((icons (edoc--org-status-icons file)))
                  (insert (format (format "â€¢ %%-%ds  %%s  %%s  %%s  %%s\n" max-name-len)
                     		name
                     		(plist-get icons :lock)
                     		(plist-get icons :enabled)
                     		(plist-get icons :draft)
                     		(plist-get icons :md))))
                (add-text-properties
                 start (point)
                 `(edoc-file ,file
                         	 mouse-face highlight
                         	 help-echo "Premi RET per aprire questo file")))))))

      (insert "\n--- â“ Premi ? per aprire il menu dei comandi e la legenda\n")
      (insert (propertize "\nâš™ï¸  [Opzioni globali Markdown]\n" 'face '(:weight bold)))
      (insert (format "%s\n" (edoc--read-options-line)))

      ;; Variabili in ordine alfabetico (allineate)
      (insert (propertize "\nðŸ’¡ [Variabili definite in vars.org]\n" 'face '(:weight bold)))
      (let* ((exclude '(:extra-documents))
             (vars (edoc--filtered-vars data exclude)))
        (if (null vars)
            (insert "   Nessuna variabile disponibile\n")
          (let ((max-key-len (apply #'max (mapcar (lambda (pair)
                                        		(length (symbol-name (car pair))))
                                        	    vars))))
            (dolist (pair vars)
              (let* ((key (upcase (substring (symbol-name (car pair)) 1)))
                     (val (cdr pair)))
                (insert (format (format "%%-%ds : %%s\n" max-key-len) key val)))))))
      
      (let ((map (make-sparse-keymap)))
	(define-key map (kbd "?") #'edoc-dashboard-menu)
        (define-key map (kbd "RET") #'edoc-dashboard-open-file-at-point)
    	(define-key map (kbd "(") #'edoc-dashboard-open-private-dired)
    	(define-key map (kbd ")") #'edoc-dashboard-open-public-dired)
      	(define-key map (kbd "r p") (lambda () (interactive) (edoc-dashboard-git-do 'push)))
      	(define-key map (kbd "r P") (lambda () (interactive) (edoc-dashboard-git-do 'pull)))
      	(define-key map (kbd "r g") (lambda () (interactive) (edoc-dashboard-git-do 'commit-push)))
      	(define-key map (kbd "r s") #'edoc-dashboard-git-status)
	(define-key map (kbd "=") #'edoc-devserver-toggle)
	(define-key map (kbd "q") #'quit-window)
	(define-key map (kbd "g") #'edoc-dashboard-refresh)
	(define-key map (kbd "S") #'edoc-dashboard-cycle-status)
	(define-key map (kbd "E") #'edoc-dashboard-toggle-enable)
	(define-key map (kbd "D") #'edoc-dashboard-toggle-enable)
	(define-key map (kbd "L") #'edoc-dashboard-toggle-lock)
	(define-key map (kbd "U") #'edoc-dashboard-toggle-lock)
	(define-key map (kbd "I") #'edoc-import-markdown)
	(define-key map (kbd "p") #'edoc-dashboard-publish-file)
	(define-key map (kbd "*") #'edoc-dashboard-upload-public)
  	(define-key map (kbd "!") #'edoc-open-public-shell)
    	(define-key map (kbd "C") #'edoc-dashboard-create-org-file)
      	(define-key map (kbd "M") #'edoc-dashboard-open-md)
	(define-key map (kbd "P") #'edoc-dashboard-publish-all)
	(define-key map (kbd "B") #'edoc-dashboard-sync-markdown)
	(use-local-map map))
      
      (goto-char (point-min))
      (when edoc--first-file-line
	(forward-line (1- edoc--first-file-line)))
      (read-only-mode 1)
      (switch-to-buffer buf))))



(defun edoc-dashboard-create-org-file ()
  "Crea un nuovo file Org nella directory dellâ€™edizione corrente e lo apre per lâ€™editing."
  (interactive)
  (let* ((name (read-string "Nome del nuovo file (senza estensione): "))
      	 (filename (concat name ".org"))
      	 (target-dir edoc-current-edition-path)
      	 (path (expand-file-name filename target-dir)))
    (if (file-exists-p path)
      	(message "âš  Il file '%s' esiste giÃ ." filename)
      (progn
      	(unless (file-directory-p target-dir)
          (make-directory target-dir t))
      	(with-temp-buffer
          (insert (format "#+TITLE: %s\n\n" name))
          (write-file path))
      	(message "âœ… File creato: %s" path)
      	(find-file path)))))


(defun edoc--org-file-md-exists-p (org-file)
  "Restituisce t se esiste un file .md corrispondente a ORG-FILE nel repo public."
  (let* ((name (file-name-base org-file))
         (md-path (expand-file-name (concat name ".md")
                                    (expand-file-name
                                     (file-relative-name edoc-current-edition-path
                                                         (edoc--repo-path "private"))
                                     (edoc--repo-path "public")))))
    (file-exists-p md-path)))

(defun edoc--md5-status-icon (file)
  "Restituisce un'icona che indica lo stato del file Markdown esportato."
  (let* ((paths (edoc--org-product-paths file)))
    (cond
     ((not (seq-some #'file-exists-p paths)) "â€”")            ;; nessun file presente
     ((edoc--md5-up-to-date-p paths) "âœ”")                    ;; hash corrispondente
     (t "âœŽ"))))                                               ;; esiste ma modificato

(defun edoc-dashboard-unlock-file ()
  "Sblocca un file Org (cambia STATUS da locked a enabled previa conferma)."
  (interactive)
  (let ((file (get-text-property (point) 'edoc-file))
        (line (line-number-at-pos)))
    (when (and file
               (string= (edoc--get-org-status file) "locked")
               (yes-or-no-p (format "Sbloccare il file %s?" (file-name-nondirectory file))))
      (edoc--set-org-status file 'enabled)
      (message "ðŸ”“ File sbloccato.")
      (edoc-dashboard-refresh)
      (edoc--goto-line line))))

(defun edoc-dashboard-lock-file ()
  "Blocca il file Org sulla riga corrente (STATUS â†’ locked)."
  (interactive)
  (let ((file (get-text-property (point) 'edoc-file))
        (line (line-number-at-pos)))
    (if (not file)
        (message "Nessun file selezionato.")
      (let ((status (edoc--get-org-status file)))
        (if (string= status "locked")
            (message "ðŸ”’ Il file Ã¨ giÃ  bloccato.")
          (edoc--set-org-status file 'locked)
          (message "ðŸ”’ File bloccato.")
          (edoc-dashboard-refresh)
          (edoc--goto-line line))))))

(defun edoc-dashboard-toggle-lock ()
  "Attiva o disattiva il blocco del file Org sulla riga corrente (modifica `#+LOCK:`)."
  (interactive)
  (let ((file (get-text-property (point) 'edoc-file))
        (line (line-number-at-pos)))
    (if (not file)
        (message "âš  Nessun file selezionato.")
      (if (edoc--get-org-lock file)
          (when (yes-or-no-p (format "ðŸ”“ Sbloccare il file %s?" (file-name-nondirectory file)))
            (edoc--set-lock file nil)
            (message "ðŸ”“ File sbloccato.")
            (edoc-dashboard-refresh)
            (edoc--goto-line line))
        (progn
          (edoc--set-lock file t)
          (message "ðŸ”’ File bloccato.")
          (edoc-dashboard-refresh)
          (edoc--goto-line line))))))


(defun edoc--set-lock (file locked)
  "Imposta `#+LOCK:` su yes o no nel FILE Org."
  (edoc--set-org-keyword file "LOCK" (if locked "yes" "no")))

(defun edoc--set-enabled (file enabled)
  "Imposta `#+ENABLED:` su yes o no nel FILE Org."
  (edoc--set-org-keyword file "ENABLED" (if enabled "yes" "no")))

(defun edoc--set-draft (file draft)
  "Imposta `#+STATUS:` su draft o cleared nel FILE Org."
  (edoc--set-org-keyword file "STATUS" (if draft "draft" "published")))


(defun edoc--set-org-keyword (file key value)
  "Imposta o aggiorna la keyword `#+KEY:` nel FILE Org con VALUE.
               KEY deve essere una stringa (es: \"LOCK\", \"ENABLED\"). VALUE deve essere una stringa."
  (when (file-exists-p file)
    (with-temp-buffer
      (insert-file-contents file)
      (org-mode)
      (let* ((upkey (upcase key))
             (re (concat "^#\\+" upkey ":\\s-*.*$")))
        (goto-char (point-min))
        (if (re-search-forward re nil t)
            (replace-match (format "#+%s: %s" upkey value))
          ;; Se la keyword non c'Ã¨, aggiungila dopo il blocco iniziale
          (goto-char (point-min))
          (while (looking-at "^#\\+")
            (forward-line 1))
          (insert (format "#+%s: %s\n" upkey value))))
      ;; Assicura che ci sia una riga vuota dopo le keyword
      (goto-char (point-min))
      (while (looking-at "^#\\+")
        (forward-line 1))
      (unless (looking-at "^\\s-*$")
        (insert "\n"))
      (write-region (point-min) (point-max) file nil 'silent))))


(defun edoc-dashboard-toggle-enable ()
  "Inverti lo STATUS del file .org sulla riga corrente."
  (interactive)
  (let ((file (get-text-property (point) 'edoc-file))
        (line (line-number-at-pos)))
    (if (not (and file (file-exists-p file)))
        (message "Nessun file .org su questa riga.")
      (let ((enabled (edoc--get-org-enabled file)))
        (if (edoc--get-org-lock file)
            (message "Il file Ã¨ bloccato ðŸ”’. Non posso operare.")
          (edoc--set-enabled file (not enabled))
          (if enabled
              (message "ðŸš« %s disabilitato." (file-name-nondirectory file)))
          (message "âœ… %s abilitato." (file-name-nondirectory file)))
        (edoc-dashboard-refresh)                                                                                                                      
        (edoc--goto-line line)))))

(defun edoc--get-org-status (filepath)
  "Restituisce il valore di `#+STATUS:` in FILEPATH, o nil se non presente."
  (when (file-readable-p filepath)
    (with-temp-buffer
      (insert-file-contents filepath nil 0 1000)
      (org-mode)
      (goto-char (point-min))
      (when (re-search-forward "^#\\+STATUS:\\s-*\\(.*\\)$" nil t)
        (string-trim (match-string 1))))))

(defun edoc--read-org-keyword-p (file key &optional test-fn)
  "Restituisce t se il file Org FILE contiene `#+KEY:` il cui valore passa TEST-FN.

           Se TEST-FN Ã¨ nil, considera vero solo se il valore Ã¨ \"yes\" o \"t\" (case-insensitive)."
  (when (file-readable-p file)
    (with-temp-buffer
      (insert-file-contents file nil 0 1000)
      (org-mode)
      (goto-char (point-min))
      (when (re-search-forward (concat "^#\\+" (upcase key) ":\\s-*\\(.*\\)$") nil t)
        (let ((val (downcase (string-trim (match-string 1)))))
          (if test-fn
              (funcall test-fn val)
            (or (string= val "yes")
                (string= val "t"))))))))

(defun edoc--get-org-lock (file)
  "Restituisce t se `#+LOCK:` Ã¨ `yes` o `t`."
  (edoc--read-org-keyword-p file "LOCK"))
(defun edoc--get-org-enabled (file)
  "Restituisce t se `#+ENABLED:` Ã¨ `yes` o `t`."
  (edoc--read-org-keyword-p file "ENABLED"))

(defun edoc--get-org-draft (file)
  "Restituisce t se `#+STATUS:` Ã¨ `draft` (case-insensitive)."
  (if (file-exists-p file)
      (if (edoc--read-org-keyword-p file "STATUS"
                                    (lambda (val) (string= val "draft")))
      	  "ðŸ“" "ðŸ“„") "âŒ"))


(defun edoc--get-org-status-value (file)
  "Restituisce il valore della keyword `#+STATUS:` in FILE, in simbolo (default: 'draft)."
  (let ((val (downcase (or (edoc--read-org-keyword-value file "STATUS") "draft"))))
    (cond
     ((string= val "published") 'published)
     ((string= val "hidden")    'hidden)
     ((string= val "skip")      'skip)
     ((string= val "draft")     'draft)
     (t                         'published)))) ; fallback

(defun edoc--status-icon (file)
  "Restituisce unâ€™icona in base alla keyword `#+STATUS:`."
  (pcase (edoc--get-org-status-value file)
    ('draft     "ðŸ“")
    ('published "ðŸ“„")
    ('hidden    "ðŸ‘ï¸â€ðŸ—¨ï¸")
    ('skip      "ðŸš«")
    (_          "â“")))

(defun edoc-dashboard-cycle-status ()
  "Cicla il valore della chiave `#+STATUS:` (draft â†’ published â†’ hidden â†’ skip â†’ draft)."
  (interactive)
  (let ((file (get-text-property (point) 'edoc-file))
        (line (line-number-at-pos)))
    (if (not file)
        (message "âš  Nessun file selezionato.")
      (let* ((current (edoc--get-org-status-value file))
             (order '(draft published hidden skip))
             (next (or (cadr (member current order)) (car order))))
        (edoc--set-org-keyword file "STATUS" (symbol-name next))
        (message "ðŸ“„ Stato aggiornato a: %s" (capitalize (symbol-name next)))
        (edoc-dashboard-refresh)
        (edoc--goto-line line)))))

(defun edoc--org-status-icons (file)
  "Restituisce un plist con le icone degli stati per il FILE Org."
  (let* ((lock (if (edoc--get-org-lock file) "ðŸ”’" "ðŸŸ©"))
         (enabled (if (edoc--get-org-enabled file) "âœ…" "â›”"))
         (status (edoc--status-icon file))
         (md-icon (cond
                   ((not (seq-some #'file-exists-p (edoc--org-product-paths file))) "ðŸ”´")
                   ((edoc--md5-up-to-date-p (edoc--org-product-paths file)) "ðŸŸ¢")
                   (t "ðŸŸ¡"))))
    (list :lock lock
          :enabled enabled
          :draft status
          :md md-icon)))

(defun edoc-dashboard-open-file-at-point ()
  "Apre il file .org associato alla riga corrente nella dashboard, se presente."
  (interactive)
  (let ((file (get-text-property (point) 'edoc-file)))
    (if (and file (file-exists-p file))
        (let ((inhibit-read-only t))
          (switch-to-buffer (find-file-noselect file)))
      (message "Nessun file .org associato a questa riga."))))


(defun edoc--dashboard-repo-info (label repo-path)
  "Restituisce una stringa con lo stato del repository."
  (let* ((commit (edoc-git-last-commit-summary repo-path))
         (status (cond
                  ((not (file-directory-p repo-path)) "âœ– non presente")
                  ((edoc-git-repo-dirty-p repo-path) "âš  modifiche locali")
                  ((not (edoc-git-up-to-date-p repo-path)) "â†¯ non aggiornato")
                  (t "âœ” aggiornato"))))
    (format "%-4s v. %40s      %s\n" label (or commit "â€”") status)))

(defun edoc--filtered-vars (plist &optional exclude)
  "Ritorna una alist ordinata delle variabili in PLIST, escludendo EXCLUDE."
  (let ((exclude (or exclude '(:extra-documents))))
    (sort
     (cl-remove-if (lambda (pair) (member (car pair) exclude))
                   (edoc--plist-to-alist plist))
     (lambda (a b) (string< (symbol-name (car a))
                            (symbol-name (car b)))))))


(defun edoc-dashboard-open-private-dired ()
  "Apre dired nella directory di lavoro dellâ€™edizione corrente (repo private)."
  (interactive)
  (let ((path edoc-current-edition-path))
    (if (and path (file-directory-p path))
        (dired path)
      (message "âš  Nessuna edizione corrente o directory non trovata."))))

(defun edoc-dashboard-open-public-dired ()
  "Apre dired nella directory corrispondente nel repo public."
  (interactive)
  (let* ((relpath (file-relative-name edoc-current-edition-path
                                      (edoc--repo-path "private")))
         (public-path (expand-file-name relpath (edoc--repo-path "public"))))
    (if (file-directory-p public-path)
        (dired public-path)
      (message "âš  Directory public non trovata: %s" public-path))))

(defun edoc--set-org-status (file status)
  "Imposta o aggiorna il valore `#+STATUS:` in FILE con STATUS ('enabled, 'disabled, ecc.)."
  (when (file-exists-p file)
    (with-temp-buffer
      (insert-file-contents file)
      (org-mode)
      (goto-char (point-min))
      (if (re-search-forward "^#\\+STATUS:\\s-*\\(.*\\)$" nil t)
          (replace-match (concat "#+STATUS: " (symbol-name status)))
        ;; Se non c'Ã¨, inserisci in alto dopo eventuali #+ altre variabili
        (goto-char (point-min))
        (if (re-search-forward "^#\\+" nil t)
            (progn
              (beginning-of-line)
              (insert "#+STATUS: " (symbol-name status) "\n"))
          (insert "#+STATUS: " (symbol-name status) "\n")))
      (write-region (point-min) (point-max) file))))


(defun edoc--goto-line (n)
  "Vai alla linea N senza attivare marker."
  (goto-char (point-min))
  (forward-line (1- n)))

(defun edoc-dashboard-open-md ()
  "Apre il file Markdown corrispondente al file Org sotto il cursore, se esiste."
  (interactive)
  (let* ((org-file (get-text-property (point) 'edoc-file))
      	 (line (line-number-at-pos)))
    (if (not org-file)
      	(message "âš  Nessun file selezionato.")
      (let* ((base (file-name-base org-file))
             (relpath (file-relative-name edoc-current-edition-path
                                          (edoc--repo-path "private")))
             (md-file (expand-file-name (concat base ".md")
      					(expand-file-name relpath
                                                          (edoc--repo-path "public")))))
      	(if (file-exists-p md-file)
            (find-file md-file)
          (message "âŒ File Markdown non trovato: %s" md-file))))))

(require 'transient)

(transient-define-prefix edoc-dashboard-menu ()
  "Pannello comandi della dashboard EPUB."
  [["ðŸ” Refresh / Navigazione"
    ("g"  "Aggiorna dashboard" edoc-dashboard-refresh)
    ("RET" "Apri file (org)" edoc-dashboard-open-file-at-point)
    ("M"  "Apri file Markdown" edoc-dashboard-open-md)
    ("("  "Dired private" edoc-dashboard-open-private-dired)
    (")"  "Dired public"  edoc-dashboard-open-public-dired)]

   ["ðŸ“‚ File Org"
    ("C" "Crea nuovo file org" edoc-dashboard-create-org-file)
    ("p" "Pubblica file corrente" edoc-dashboard-publish-file)
    ("P" "Pubblica tutto" edoc-dashboard-publish-all)
    ("B" "Backup + diff Markdown" edoc-dashboard-sync-markdown)
    ("I" "Importa da public" edoc-import-markdown)]

   ["ðŸ“¡ Git"
    ("r s" "Git status" edoc-dashboard-git-status)
    ("r p" "Push"       (lambda () (interactive) (edoc-dashboard-git-do 'push)))
    ("r P" "Pull"       (lambda () (interactive) (edoc-dashboard-git-do 'pull)))
    ("r g" "Commit + Push" (lambda () (interactive) (edoc-dashboard-git-do 'commit-push)))]

   ["ðŸš€ Altri"
    ("*" "Upload sito (rsync)" edoc-dashboard-upload-public)
    ("!" "Apri shell in public/" edoc-open-public-shell)
    ("=" "Attiva/disattiva dev server" edoc-devserver-toggle)
    ("q" "Chiudi dashboard" quit-window)]

   ["ðŸ“„ Legenda Colonne:"
    ("L" "ðŸ”’ / ðŸŸ© = Locked / Unlocked" edoc-dashboard-toggle-lock)
    ("D" "âœ… / â›” = Enabled / Disabled" edoc-dashboard-toggle-enable)
    ("3" "ðŸ“ / ðŸ“„ / ðŸ‘ï¸â€ðŸ—¨ï¸ / ðŸš« = Draft / Pubblicato / Nascosto / Skip" 
     edoc-dashboard-cycle-status)
    ("-" "ðŸ”´ / ðŸŸ¡ / ðŸŸ¢ = No MD5 / MD5 errata / MD5 ok"
     (lambda () (interactive) (message "Legenda â€” stato MD5")))]])

(defvar edoc--devserver-buffer-name "*Shell:Devserver*"
  "Buffer dedicato al devserver pelican.")

(defun edoc-devserver-running-p ()
  "Restituisce t se il devserver Ã¨ attivo (cioÃ¨ se esiste un buffer con processo vivo)."
  (let ((proc (get-buffer-process edoc--devserver-buffer-name)))
    (and proc (process-live-p proc))))

(defun edoc-devserver-toggle ()
  "Attiva o disattiva il devserver con `make devserver` / `make stopserver`."
  (interactive)
  (let ((default-directory (edoc--repo-path "public")))
    (if (edoc-devserver-running-p)
        ;; Spegnimento: make stopserver
        (progn
          (with-current-buffer edoc--devserver-buffer-name
            (goto-char (point-max))
            (insert "make stopserver")
            (comint-send-input)
            (message "ðŸ›‘ Devserver in fase di spegnimento... (make stopserver inviato)")
            (sit-for 5.0)
	    (insert "exit")
	    (comint-send-input)
	    (kill-buffer edoc--devserver-buffer-name))
          (edoc-dashboard-refresh))
      ;; Avvio: make devserver
      (with-current-buffer (get-buffer-create edoc--devserver-buffer-name)
        (shell (current-buffer))
        (goto-char (point-max))
        (insert "make devserver")
        (comint-send-input)
        (message "ðŸ”¥ Devserver avviato. Puoi vedere il sito su http://test.winstonsmith.org"))
      (edoc-dashboard-refresh))))

(provide 'edoc-dashboard)
#+END_SRC


* edoc.el - Entry point del sistema

Punto di ingresso del sistema: caricamento pacchetti, definizione di `defcustom` e variabili globali, gestione dellâ€™edizione corrente.


#+BEGIN_SRC emacs-lisp :tangle edoc.el
;;; edoc.el --- Entry point PWS -*- lexical-binding: t -*-

(require 'seq)
(require 'subr-x)
(require 'roman-numerals)
(require 'edoc-vars)

(defgroup edoc nil
  "Sistema di pubblicazione EPrivacy."
  :group 'applications)

(defcustom edoc-current-edition-path "~/production-site/private/content/2025/summer/"
  "Percorso dellâ€™edizione EPrivacy in lavorazione."
  :type 'directory
  :group 'edoc)

(defcustom edoc-repo-private
  "git@github.com-pws:progettowinstonsmith/eprivacy-org-db.git"
  "Repository Git privato contenente i sorgenti Org."
  :type 'string
  :group 'edoc)

(defcustom edoc-repo-public
  "git@github.com-pws:progettowinstonsmith/e-privacy-site.git"
  "Repository Git pubblico contenente il sito generato."
  :type 'string
  :group 'edoc)

(defcustom edoc-production-dir
  "~/production-site"
  "Directory di lavoro contenente i repository clonati."
  :type 'directory
  :group 'edoc)

(defun edoc--repo-path (name)
  "Restituisce il path assoluto di un sotto-repo dentro `edoc-production-dir`,
oppure `~/epub-system` se NAME Ã¨ \"sw\"."
  (if (string= name "sw")
      (expand-file-name "~/epub-system")
    (expand-file-name name edoc-production-dir)))

(defun edoc-clone-repos ()
  "Clona i repository se non esistono giÃ  nella `production-dir`."
  (interactive)
  (let ((default-directory edoc-production-dir))
    (unless (file-directory-p edoc-production-dir)
      (make-directory edoc-production-dir t))
    (dolist (repo `(("private" . ,edoc-repo-private)
                    ("public"  . ,edoc-repo-public)))
      (let* ((name (car repo))
             (url (cdr repo))
             (target (edoc--repo-path name)))
        (if (file-directory-p target)
            (message "Repo '%s' giÃ  clonato." name)
          (message "Clonazione di '%s' da %s..." name url)
          (call-process "git" nil "*edoc-git*" t "clone" url name)
          (message "âœ” Clonato %s in %s" name target))))))

(defun edoc-pull-repos ()
  "Esegue `git pull` nei repository clonati nella production-dir."
  (interactive)
  (dolist (repo-name '("private" "public"))
    (let ((repo-path (edoc--repo-path repo-name)))
      (if (file-directory-p repo-path)
          (let ((default-directory repo-path))
            (message "Aggiornamento repo %s..." repo-name)
            (call-process "git" nil "*edoc-git*" t "pull" "--ff-only")
            (message "âœ” Pull completato in %s" repo-path))
        (message "âš  Repo %s non trovato, forse serve `edoc-clone-repos`?" repo-name)))))

(defun edoc--list-subdirectories (dir)
  "Restituisce le sottodirectory non nascoste presenti in DIR."
  (when (file-directory-p dir)
    (let ((entries (directory-files dir nil nil t)))
      (seq-filter
       (lambda (name)
         (let ((full (expand-file-name name dir)))
           (and (file-directory-p full)
                (not (string-prefix-p "." name)))))
       entries))))

(defun edoc--read-vars-keywords (vars-file)
  "Restituisce (KEYS . ALIST) leggendo tutte le keyword da VARS-FILE."
  (when (file-readable-p vars-file)
    (with-temp-buffer
      (insert-file-contents vars-file)
      (goto-char (point-min))
      (let (keys pairs)
        (while (re-search-forward "^#\\+\\([A-Z0-9_]+\\):\\s-*\\(.*\\)$" nil t)
          (let ((key (match-string 1))
                (val (string-trim (match-string 2))))
            (push key keys)
            (push (cons key val) pairs)))
        (cons (nreverse (delete-dups (nreverse keys)))
              (nreverse pairs))))))

(defun edoc--read-front-matter (file)
  "Parsa il blocco iniziale `Chiave: Valore` da FILE Markdown."
  (when (file-readable-p file)
    (with-temp-buffer
      (insert-file-contents file)
      (goto-char (point-min))
      (let (result continue)
        (setq continue t)
        (while (and continue (not (eobp)))
          (let ((line (buffer-substring-no-properties
                       (line-beginning-position) (line-end-position))))
            (cond
             ((string-match "^\\s*$" line)
              (setq continue nil))
             ((string-match "^\\([A-Za-z0-9_ -]+\\):\\s-*\\(.*\\)$" line)
              (let ((key (upcase (replace-regexp-in-string " " "_" (match-string 1 line))))
                    (val (string-trim (match-string 2 line))))
                (push (cons key val) result)))
             (t (setq continue nil))))
          (forward-line 1))
        (nreverse result)))))

(defun edoc--find-session-markdown (year session public-dir)
  "Trova il file Markdown principale per l'anno YEAR e la SESSION dentro PUBLIC-DIR."
  (let* ((dir public-dir)
         (files (when (file-directory-p dir)
                  (directory-files dir nil "\\.md$" t)))
         (cfp (seq-find (lambda (f) (string= f "cfp.md")) files)))
    (cond
     (cfp (expand-file-name cfp dir))
     (files
      (let* ((year-pattern (regexp-quote year))
             (candidates (seq-filter (lambda (f)
                                       (string-match-p year-pattern (downcase f)))
                                     files)))
        (when candidates
          (expand-file-name (car candidates) dir)))))))

(defun edoc--write-vars-template (dest-file keys-alist front-alist)
  "Scrive DEST-FILE usando le KEYWORD disponibili.
KEYS-ALIST Ã¨ una cons cell (KEYS . ALIST) letta da un `vars.org`
esistente; FRONT-ALIST contiene le coppie (KEY . VAL) trovate nel
Markdown."
  (let* ((keys-source (car-safe keys-alist))
         (base (cdr keys-alist))
         (front front-alist)
         (keys (delete-dups (copy-sequence (or keys-source (mapcar #'car front))))))
    (unless keys
      (user-error "Impossibile determinare le chiavi per vars.org"))
    (with-temp-file dest-file
      (dolist (key keys)
        (let* ((val (or (cdr (assoc key front))
                        (cdr (assoc key base))
                        "")))
          (insert (format "#+%s: %s\n" key val)))))))

(defun edoc-select-edition ()
  "Permette di scegliere interattivamente l'edizione corrente.
Prima propone l'anno tra le directory esistenti in `public/content/`,
poi la sessione (es. `summer`, `winter`). Aggiorna
`edoc-current-edition-path` al percorso corrispondente nel repository
privato."
  (interactive)
  (let* ((public-content (expand-file-name "content" (edoc--repo-path "public")))
         (years (edoc--list-subdirectories public-content)))
    (unless years
      (user-error "Nessun anno trovato in %s" public-content))
    (let* ((year (completing-read "Anno: " years nil t nil nil (car years)))
           (year-dir (expand-file-name year public-content))
           (sessions (edoc--list-subdirectories year-dir)))
      (unless sessions
        (user-error "Nessuna sessione trovata per l'anno %s" year))
      (let* ((session (completing-read "Sessione: " sessions nil t nil nil (car sessions)))
             (private-target (expand-file-name (format "content/%s/%s/" year session)
                                               (edoc--repo-path "private")))
             (public-target (expand-file-name (format "content/%s/%s/" year session)
                                              (edoc--repo-path "public")))
             (previous-path edoc-current-edition-path)
             (previous-vars (edoc--read-vars-keywords
                             (expand-file-name "vars.org" previous-path)))
             (front-matter (edoc--read-front-matter
                            (or (edoc--find-session-markdown year session public-target)
                                (expand-file-name "cfp.md" public-target)))))
        (unless (file-directory-p public-target)
          (message "âš  Directory pubblica mancante: %s" public-target))
        (unless (file-directory-p private-target)
          (make-directory private-target t)
          (message "Creata directory privata: %s" private-target)
          (let ((dest-vars (expand-file-name "vars.org" private-target)))
            (if (or (car-safe previous-vars) front-matter)
                (progn
                  (edoc--write-vars-template dest-vars (or previous-vars (cons nil nil)) front-matter)
                  (message "Creato %s" dest-vars))
              (with-temp-file dest-vars
                (insert "#+TITLE: TODO\n"))
              (message "Creato %s (vuoto)" dest-vars))))
        (setq edoc-current-edition-path private-target)
        (message "edoc-current-edition-path â†’ %s" edoc-current-edition-path)))))

(defun edoc--next-session (year session)
  "Restituisce (cons NEXT-YEAR NEXT-SESSION) per la prossima sessione.
Ciclo: summer â†’ winter â†’ (next year) summer."
  (pcase session
    ("summer" (cons year "winter"))
    ("winter" (cons (number-to-string (1+ (string-to-number year))) "summer"))
    (_ (cons year "summer"))))

(defun edoc-create-next-edition ()
  "Crea la prossima edizione in public/content/ANNO/SESSION/.
Basato su edoc-current-edition-path: calcola ANNO e SESSION, 
poi genera la cartella successiva nel ciclo (summer â†’ winter â†’ next year summer)."
  (interactive)
  (let* ((path (expand-file-name edoc-current-edition-path))
         (parts (split-string path "/" t))
         (len (length parts))
         (current-year (nth (- len 2) parts))
         (current-session (nth (- len 1) parts)))
    (unless (and current-year current-session (string-match-p "^[0-9]\\{4\\}$" current-year))
      (user-error "Non riesco a estrarre anno/sessione da: %s" path))
    (let* ((next (edoc--next-session current-year current-session))
           (next-year (car next))
           (next-session (cdr next))
           (public-base (expand-file-name "content" (edoc--repo-path "public")))
           (public-target (expand-file-name (format "%s/%s" next-year next-session) public-base)))
      (message "Creazione prossima edizione: %s/%s" next-year next-session)
      (if (file-directory-p public-target)
          (message "âš ï¸  Directory giÃ  esiste: %s" public-target)
        (make-directory public-target t)
        (message "âœ… Creata: %s" public-target))
      (message "Usa M-x edoc-select-edition per configurare la versione privata."))))

(defun edoc--detect-next-session-by-month ()
  "Restituisce 'spring'/'summer' (primo semestre) o 'autumn'/'winter' (secondo semestre).
Basato sul mese corrente: gen-giu â†’ spring/summer, lug-dic â†’ autumn/winter.
Usa semestralmente alternato (spring â†’ summer, autumn â†’ winter)."
  (let* ((month (nth 4 (decode-time)))
         (is-first-half (< month 7)))
    (if is-first-half
        (if (< month 5) "spring" "summer")
      (if (< month 10) "autumn" "winter"))))

(defun edoc--next-edition-number (current-num-str)
  "Calcola il prossimo numero edizione da CURRENT-NUM-STR (es. 'XXXVI').
Se Ã¨ un numero romano, converti a int, +1, riconverti. Altrimenti usa '1'."
  (if (and current-num-str (string-match "[IVXLCDM]" current-num-str))
      (let ((current-int (condition-case nil
                           (roman-numeral-parse current-num-str)
                           (error 1))))
        (roman-numeral (1+ current-int)))
    "I"))

(defun edoc--copy-vars-org (src-vars-path dest-vars-path new-vars)
  "Copia SRC-VARS-PATH a DEST-VARS-PATH, aggiornando le keyword con NEW-VARS.
NEW-VARS Ã¨ un alist di (KEY . VALUE) (es. ((\"NUM\" . \"XXXVII\") (\"TITLE\" . \"...\")))."
  (with-temp-buffer
    (insert-file-contents src-vars-path)
    (dolist (pair new-vars)
      (let ((key (car pair))
            (value (cdr pair)))
        (goto-char (point-min))
        (if (re-search-forward (format "^#\\+%s:\\s-*\\(.*\\)$" key) nil t)
            (replace-match (format "#+%s: %s" key value) nil nil)
          (goto-char (point-max))
          (insert (format "\n#+%s: %s" key value)))))
    (write-file dest-vars-path)))

(defun edoc-create-new-edition-wizard ()
  "Wizard interattivo per creare una nuova edizione completa.
Chiede venue, sessioni, numero, e popola vars.org."
  (interactive)
  (let* ((path (expand-file-name edoc-current-edition-path))
         (parts (split-string path "/" t))
         (len (length parts))
         (current-year (nth (- len 2) parts))
         (current-session (nth (- len 1) parts))
         (current-vars-path (expand-file-name "vars.org" path)))
    (unless (and current-year current-session)
      (user-error "Non riesco a estrarre anno/sessione da: %s" path))
    
    ;; Chiedi informazioni
    (let* ((next (edoc--next-session current-year current-session))
           (next-year (car next))
           (next-session (cdr next))
           (venue (read-string "Venue (cittÃ /luogo): "))
           (num-sessioni (completing-read "Sessioni: " '("1 (un giorno)" "2 (due giorni)") nil t))
           (when-text (if (string-prefix-p "1" num-sessioni)
                          (read-string "Data (es. 15 maggio 2026): ")
                        (read-string "Date (es. 15-16 maggio 2026): ")))
           (previous-vars (edoc-parse-vars current-vars-path))
           (previous-num (plist-get previous-vars :num))
           (next-num (edoc--next-edition-number previous-num))
           (next-label (read-string "Label (es. numero romano) [default: auto]: " next-num))
           (public-base (expand-file-name "content" (edoc--repo-path "public")))
           (public-target (expand-file-name (format "%s/%s" next-year next-session) public-base))
           (private-base (expand-file-name "content" (edoc--repo-path "private")))
           (private-target (expand-file-name (format "%s/%s" next-year next-session) private-base))
           (dest-vars-path (expand-file-name "vars.org" private-target)))
      
      ;; Crea directory pubblica
      (unless (file-directory-p public-target)
        (make-directory public-target t)
        (message "Creata directory pubblica: %s" public-target))
      
      ;; Crea directory privata
      (unless (file-directory-p private-target)
        (make-directory private-target t)
        (message "Creata directory privata: %s" private-target))
      
      ;; Copia e aggiorna vars.org
      (let ((new-vars `(("YEAR" . ,next-year)
                        ("SEASON" . ,next-session)
                        ("NUM" . ,next-label)
                        ("CITY" . ,venue)
                        ("LOCATION" . ,venue)
                        ("WHEN" . ,when-text)
                        ("EDITION" . ,next-session)
                        ("STATUS" . "draft")
                        ("LOCK" . ""))))
        (edoc--copy-vars-org current-vars-path dest-vars-path new-vars)
        (message "Creato vars.org con metadati aggiornati"))
      
      ;; Crea options.org minimo
      (let ((options-path (expand-file-name "options.org" private-target)))
        (unless (file-exists-p options-path)
          (with-temp-file options-path
            (insert "#+OPTIONS: toc:nil\n"))
          (message "Creato options.org stub")))
      
      ;; Aggiorna edoc-current-edition-path
      (setq edoc-current-edition-path private-target)
      (message "edoc-current-edition-path -> %s" edoc-current-edition-path)
      (message "Nuova edizione %s/%s pronta!" next-year next-session))))

(provide 'edoc)
#+END_SRC


* edoc-import.el - Importazione Markdown â†’ Org

Questa sezione definisce una funzione interattiva per importare un file `.md` dal repository pubblico (`public`)
alla directory corrispondente del repository privato (`private`), convertendolo in Org Mode tramite `pandoc`.

Lâ€™operazione Ã¨ sicura: il file `.org` viene generato solo se non esiste giÃ  nella destinazione.

#+BEGIN_SRC emacs-lisp  :tangle edoc-export.el
;;; edoc-export.el --- Funzioni di esportazione -*- lexical-binding: t -*-

(require 'edoc-org-program)
(defun edoc--org-product-paths (file)
  "Restituisce la lista completa dei path dei file da produrre (in `public/`) per un FILE Org."
  (let* ((base (file-name-base file))
         (relpath (file-relative-name edoc-current-edition-path
                                      (edoc--repo-path "private")))
         (target-dir (expand-file-name relpath (edoc--repo-path "public")))
         (product-line (edoc--read-org-keyword-value file "PRODUCT")))
    (if product-line
        ;; split su virgole e/o spazi, rimuove vuoti
        (let ((names (split-string product-line "[,[:space:]]+" t)))
          (mapcar (lambda (name) (expand-file-name name target-dir)) names))
      ;; default: nome file org -> .md
      (list (expand-file-name (concat base ".md") target-dir)))))

(defun edoc--product-exists-p (file)
  "Restituisce t se almeno uno dei file prodotti da FILE esiste giÃ ."
  (seq-some #'file-exists-p (edoc--org-product-paths file)))


(defun edoc--make-markdown-backup (path)
  "Copia PATH in un backup timestamped nella stessa directory e restituisce il nuovo path.
Restituisce nil se PATH non esiste."
  (when (file-exists-p path)
    (let* ((dir (file-name-directory path))
           (stamp (format-time-string "%Y%m%d-%H%M%S"))
           (backup (expand-file-name
                    (format "%s.%s.md" (file-name-base path) stamp)
                    dir)))
      (copy-file path backup t)
      backup)))

(defun edoc--make-org-backup (path)
  "Crea un backup timestamped del file Org in PATH e restituisce il nuovo path.
Restituisce nil se PATH non esiste."
  (when (file-exists-p path)
    (let* ((dir (file-name-directory path))
           (stamp (format-time-string "%Y%m%d-%H%M%S"))
           (backup (expand-file-name
                    (format "%s.%s.org" (file-name-base path) stamp)
                    dir)))
      (copy-file path backup t)
      backup)))

(defun edoc--export-org-file-noninteractive (file)
  "Esporta FILE in Markdown senza prompt, restituendo i path dei prodotti generati."
  (let* ((product-paths (edoc--org-product-paths file))
         (export-label (edoc--read-org-keyword-value file "PWS_EXPORT")))
    (dolist (path product-paths)
      (let ((dir (file-name-directory path)))
        (unless (file-directory-p dir)
          (make-directory dir t))))
    (cond
     (export-label
      (let* ((fun-name (intern (format "edoc-export-org-%s-to-markdown" export-label))))
        (unless (fboundp fun-name)
          (user-error "Funzione export '%s' non trovata." fun-name))
        (funcall fun-name file (car product-paths))))
     (t
      (let* ((vars-path (expand-file-name "vars.org" edoc-current-edition-path))
             (options-path (expand-file-name "options.org" edoc-current-edition-path))
             (vars (edoc--setup-synth-vars
                    (edoc--combine-org-vars file)
                    edoc--synth-rules-vars
                    file))
             (header (edoc--org-vars-to-md-header vars))
             (org-source (with-temp-buffer
                           (when (file-exists-p options-path)
                             (insert-file-contents options-path))
                           (insert-file-contents file)
                           (buffer-string)))
             (exported-md (org-export-string-as org-source 'md t)))
        (with-temp-file (car product-paths)
          (insert header)
          (insert exported-md)))))
    (edoc--write-md5-file product-paths)
    product-paths))

(defun edoc--diff-markdown-pairs (pairs)
  "Mostra in un buffer dedicato le differenze tra le coppie di file PAIRS.
Ogni elemento di PAIRS Ã¨ una cons cell (CURRENT . BACKUP)."
  (cond
   ((null pairs)
    nil)
   ((not (executable-find "diff"))
    (message "âš ï¸ Utility 'diff' non disponibile: confronto saltato."))
   (t
    (let ((buffer (get-buffer-create "*edoc-markdown-diff*")))
      (with-current-buffer buffer
        (setq buffer-read-only nil)
        (erase-buffer)
        (insert (format "Diff markdown generati %s\n\n" (format-time-string "%Y-%m-%d %H:%M")))
        (dolist (pair pairs)
          (let* ((current (car pair))
                 (backup (cdr pair))
                 (label (file-name-nondirectory current))
                 (exit-code (call-process "diff" nil t nil "-u" backup current)))
            (insert (format "## %s (backup: %s)\n" label (file-name-nondirectory backup)))
            (pcase exit-code
              (0 (insert "Nessuna differenza.\n\n"))
              (1 (insert "\n"))
              (_ (insert (format "[diff fallita: codice %s]\n\n" exit-code))))
            (insert "\n")))
        (goto-char (point-min))
        (diff-mode)
        (setq buffer-read-only t))
      (display-buffer buffer)))))

(defun edoc--merge-markdown-into-org (org-file markdown-backup)
  "Avvia una sessione di merge tra ORG-FILE e MARKDOWN-BACKUP convertito in Org."
  (if (not (executable-find "pandoc"))
      (message "âŒ Impossibile convertire: pandoc non trovato nel PATH.")
    (let* ((temp-org (make-temp-file "edoc-md-merge" nil ".org"))
           (exit-code (call-process "pandoc" nil nil nil
                                    "-f" "markdown" "-t" "org"
                                    markdown-backup "-o" temp-org)))
      (if (not (zerop exit-code))
          (message "âŒ Conversione pandoc fallita (codice %s)." exit-code)
        (let ((org-backup (edoc--make-org-backup org-file)))
          (when org-backup
            (message "ðŸ—ƒ Backup Org salvato in %s" (file-name-nondirectory org-backup)))
          (ediff-merge-files org-file temp-org))))))

(defun edoc-dashboard-sync-markdown ()
  "Esegue backup, rigenerazione e diff del Markdown associato al file Org corrente.
Su richiesta avvia un merge per riportare le differenze nell'Org originale."
  (interactive)
  (let ((file (get-text-property (point) 'edoc-file)))
    (unless file
      (user-error "Posizionati su una riga con un file Org."))
    (when (edoc--get-org-lock file)
      (user-error "Il file Ã¨ bloccato. Sbloccalo prima di proseguire."))
    (let* ((product-paths (edoc--org-product-paths file))
           (pairs (mapcar (lambda (path)
                            (let ((backup (edoc--make-markdown-backup path)))
                              (cons path backup)))
                          product-paths)))
      (edoc--export-org-file-noninteractive file)
      (let ((existing (seq-filter (lambda (pair) (cdr pair)) pairs)))
        (if existing
            (edoc--diff-markdown-pairs existing)
          (message "âœ… Markdown rigenerato (nessun file precedente da confrontare)."))
        (when (and existing
                   (yes-or-no-p "Vuoi avviare il merge per riportare le modifiche nell'Org?"))
          (edoc--merge-markdown-into-org file (cdar existing))))
      (edoc-dashboard-refresh))))
#+end_src

** Sincronizzazione Markdown dall'Org corrente (fuori dal dashboard)
Implementa lo stesso flusso di "backup â†’ rigenerazione â†’ diff" ma utilizzabile da qualsiasi
buffer Org, senza passare dalla dashboard.

#+BEGIN_SRC emacs-lisp  :tangle edoc-export.el
(defun edoc-sync-markdown ()
  "Esegue backup, rigenerazione e diff del Markdown per il file Org visitato.

Passi:
- Crea un backup timestamped dei file Markdown di destinazione, se esistono.
- Rigenera i Markdown dall'Org corrente usando le regole di export configurate.
- Mostra un buffer di diff con le differenze trovate.
- Facoltativamente, propone un merge assistito per riportare le modifiche nell'Org."
  (interactive)
  (unless (derived-mode-p 'org-mode)
    (user-error "Apri un file Org per usare questa funzione."))
  (let ((file (or (buffer-file-name)
                  (user-error "Il buffer non Ã¨ associato a un file."))))
    (when (edoc--get-org-lock file)
      (user-error "Il file Ã¨ bloccato. Sbloccalo prima di proseguire."))
    (unless (file-in-directory-p file edoc-current-edition-path)
      (user-error (concat "Il file non Ã¨ sotto `edoc-current-edition-path`.\n"
                          "Configura `edoc-current-edition-path` prima di procedere.")))
    (let* ((product-paths (edoc--org-product-paths file))
           (pairs (mapcar (lambda (path)
                            (let ((backup (edoc--make-markdown-backup path)))
                              (cons path backup)))
                          product-paths)))
      ;; Rigenera i Markdown dal file Org
      (edoc--export-org-file-noninteractive file)
      ;; Filtra i soli path per cui esisteva un backup (ossia il file md era giÃ  presente)
      (let ((existing (seq-filter (lambda (pair) (cdr pair)) pairs)))
        (if existing
            (edoc--diff-markdown-pairs existing)
          (message "âœ… Markdown rigenerato (nessun file precedente da confrontare)."))
        (when (and existing
                   (yes-or-no-p "Vuoi avviare il merge per riportare le modifiche nell'Org?"))
          ;; Usa il primo backup disponibile per avviare il merge assistito
          (edoc--merge-markdown-into-org file (cdar existing)))))))



(defun edoc--read-org-keyword-value (file key)
  "Restituisce il valore della keyword `#+KEY:` nel FILE, oppure nil se assente."
  (when (file-readable-p file)
    (with-temp-buffer
      (insert-file-contents file nil 0 1000)
      (org-mode)
      (goto-char (point-min))
      (when (re-search-forward (concat "^#\\+" (upcase key) ":\\s-*\\(.*\\)$") nil t)
        (string-trim (match-string 1))))))


(defun edoc--prepend-md-header (md-file header)
  "Aggiunge HEADER (stringa multilinea) in testa a MD-FILE."
  (when (and (file-exists-p md-file)
             (file-writable-p md-file))
    (let ((old-content (with-temp-buffer
                         (insert-file-contents md-file)
                         (buffer-string))))
      (with-temp-file md-file
        (insert header)
        (insert old-content)))))

(defun edoc-dashboard-publish-file ()
  "Esporta il file Org corrente in Markdown nella directory public, e lo blocca.
Se esiste `#+PWS_EXPORT:` viene chiamata una funzione personalizzata `edoc-export-org-<label>-to-markdown`.
Se esiste `#+PRODUCT:` vengono generati piÃ¹ file. Se almeno uno esiste, viene chiesta conferma per sovrascrivere.
Chiede conferma anche per il blocco del file al termine."
  (interactive)
  (let ((file (get-text-property (point) 'edoc-file))
        (line (line-number-at-pos)))
    (if (not file)
        (message "âš  Nessun file selezionato.")
      (if (edoc--get-org-lock file)
          (message "âŒ Il file Ã¨ bloccato. Usa 'U' per sbloccarlo.")
        (let* ((product-paths (edoc--org-product-paths file))
               (export-label (edoc--read-org-keyword-value file "PWS_EXPORT")))
          ;; Conferma se esistono giÃ  prodotti
          (when (and product-paths
                     (edoc--product-exists-p file)
                     (not (yes-or-no-p "âš  Alcuni file di destinazione esistono. Sovrascriverli?")))
            (user-error "â›” Esportazione annullata."))
          ;; Crea directory
          (dolist (p product-paths)
            (let ((dir (file-name-directory p)))
              (unless (file-directory-p dir)
                (make-directory dir t))))
          ;; Esegue l'esportazione
          (cond
           ;; Personalizzata via PWS_EXPORT
           (export-label
            (let* ((fun-name (intern (format "edoc-export-org-%s-to-markdown" export-label))))
              (if (fboundp fun-name)
                  (progn
                    (funcall fun-name file (car product-paths))
                    (when (yes-or-no-p "ðŸ”’ Bloccare il file dopo l'esportazione?")
                      (edoc--set-lock file t))
                    (message "âœ… Esportato con `%s`:\nâ†’ %s"
                             export-label
                             (mapconcat #'file-relative-name product-paths "\nâ†’ "))
                    (edoc-dashboard-refresh)
                    (edoc--goto-line line))
                (message "âŒ Funzione export '%s' non trovata." fun-name))))
  	   (t
  	    (let* ((vars-path (expand-file-name "vars.org" edoc-current-edition-path))
		   (options-path (expand-file-name "options.org" edoc-current-edition-path))
  		   (target-md (car product-paths))
  		   (vars (edoc--setup-synth-vars
  			  (edoc--combine-org-vars file)
  			  edoc--synth-rules-vars
  			  file))
  		   (header (edoc--org-vars-to-md-header vars))
  		   (org-source (with-temp-buffer
				 (when (file-exists-p options-path)
				   (insert-file-contents options-path))
  				 (insert-file-contents file)
  				 (buffer-string)))
  		   (exported-md (org-export-string-as org-source 'md t)))
  	      ;; Scrive il file finale con intestazione + corpo
  	      (with-temp-file target-md
  		(insert header)
  		(insert exported-md))
	      
  	      ;; Genera il file .md5
  	      (edoc--write-md5-file product-paths)
	      
  	      ;; Blocca se confermato
  	      (when (yes-or-no-p "ðŸ”’ Bloccare il file dopo l'esportazione?")
  		(edoc--set-lock file t))
	      
  	      ;; Mostra conferma e aggiorna UI
  	      (message "âœ… Esportato:\nâ†’ %s"
  		       (mapconcat #'file-relative-name product-paths "\nâ†’ "))
  	      (edoc-dashboard-refresh)
  	      (edoc--goto-line line))
  	    )))))))


(defun edoc--setup-synth-vars (vars rules file)
  "Ritorna un alist con VARS esteso dalle variabili sintetiche definite in RULES.
Ogni funzione di RULES riceve l'alist completo `result`, che include anche:
 - FILE: il path assoluto del file
 - FILE_BASE: il nome del file senza estensione"
  (let* ((file (expand-file-name file))
         (file-base (file-name-base file))
         (result (copy-sequence vars)))
    ;; Iniettiamo le info di contesto nel set di variabili
    ;; Applichiamo le regole sintetiche in ordine
    (dolist (rule rules result)
      (let ((key (car rule))
            (synth-fn (cdr rule)))
        (unless (assoc key result)
          (let ((value (funcall synth-fn result file)))
            (setq result (plist-put result  key value))))))))


(defun edoc--read-org-keywords (file)
  "Legge tutte le keyword `#+KEY:` da FILE e restituisce un plist."
  (with-temp-buffer
    (insert-file-contents file nil 0 1000)
    (org-mode)
    (let ((parsed (org-element-parse-buffer))
          result)
      (org-element-map parsed 'keyword
        (lambda (el)
          (let ((key (org-element-property :key el))
                (val (org-element-property :value el)))
            (when (and key val)
              (setq result (plist-put result
                                      (intern (concat ":" (downcase key)))
                                      (string-trim val)))))))
      result)))

(defun edoc--combine-org-vars (file)
  "Combina le variabili di vars.org e quelle locali del FILE.
Le keyword locali sovrascrivono quelle globali. LOCK viene escluso."
  (let* ((vars-file (expand-file-name "vars.org" edoc-current-edition-path))
	 (global-vars (edoc-parse-vars vars-file))
         (local-vars (edoc--read-org-keywords file))
         (combined (copy-sequence global-vars)))
    ;; Sovrascrivi le globali con le locali
    (while local-vars
      (let ((key (pop local-vars))
            (val (pop local-vars)))
        (setq combined (plist-put combined key val))))
    ;; Rimuovi LOCK
    (setq combined (edoc--remove-from-plist combined :lock))
    combined))

(defun edoc--remove-from-plist (plist key)
  "Rimuove la coppia KEY dal PLIST se presente."
  (let (result)
    (while plist
      (let ((k (pop plist))
            (v (pop plist)))
        (unless (eq k key)
          (setq result (plist-put result k v)))))
    result))

(defun edoc-dashboard-publish-all ()
  "Esporta tutti i file Org abilitati dellâ€™edizione corrente."
  (interactive)
  (let* ((dir edoc-current-edition-path)
         (files (directory-files dir t "\\.org$"))
         (enabled-files (seq-filter #'edoc--get-org-enabled files)))
    (if (null enabled-files)
        (message "âš  Nessun file abilitato da esportare.")
      (when (yes-or-no-p (format "Esportare %d file abilitati?" (length enabled-files)))
        (dolist (file enabled-files)
          (with-temp-buffer
            (insert-file-contents file nil 0 1000)
            (goto-char (point-min))
            (let ((buf (current-buffer)))
              (let ((inhibit-message t)
                    (edoc--in-batch-export t)) ;; variabile dinamica per silenziare messaggi
                (let ((buffer (current-buffer)))
                  (with-current-buffer (get-buffer-create "*edoc-export-log*")
                    (goto-char (point-max))
                    (insert (format "\n---\nExporting: %s\n" (file-name-nondirectory file))))
                  ;; imposta proprietÃ  temporanee e chiama la funzione
                  (with-current-buffer (get-buffer "*PWS Dashboard*")
                    (save-excursion
                      (goto-char (point-min))
                      (when (re-search-forward (regexp-quote (file-name-nondirectory file)) nil t)
                        (put-text-property (point-at-bol) (point-at-eol) 'edoc-file file)
                        (goto-char (point-at-bol))
                        (call-interactively #'edoc-dashboard-publish-file)))))))))
        (message "âœ… Esportazione batch completata.")
        (display-buffer "*edoc-export-log*")))))


(defun edoc-dashboard-upload-public ()
  "Chiede conferma e, se confermato, esegue `make rsync_upload` nella directory public e aggiorna `.last`."
  (interactive)
  (let ((public-root (edoc--repo-path "public")))
    (if (file-directory-p public-root)
        (if (yes-or-no-p "ðŸ” Vuoi procedere con lâ€™upload del sito pubblico via `make rsync_upload`?")
            (edoc-upload-if-ok public-root)
          (message "âŒ Upload annullato."))
      (message "âš ï¸  Directory public non trovata: %s" public-root))))

(defun edoc-upload-if-ok (public-root)
  "Esegue `make rsync_upload` nella directory PUBLIC-ROOT. Se il comando ha successo,
crea o aggiorna il file `.last` nella stessa directory con il timestamp corrente."
  (interactive "DDirectory principale della public/: ")
  (let ((default-directory (file-name-as-directory (expand-file-name public-root)))
	(last-file ".last"))
    (message "Avvio: make rsync_upload in %s" default-directory)
    (let ((exit-code (call-process "make" nil "*rsync-upload*" t "rsync_upload")))
      (if (eq exit-code 0)
          (progn
            (with-temp-file (expand-file-name last-file default-directory)
              (insert (format-time-string "%Y-%m-%d %H:%M:%S\n")))
            (message "Upload completato con successo. File `.last` aggiornato."))
	(message "Errore durante l'upload (codice %s). File `.last` NON aggiornato." exit-code)))))

(defun edoc-start-devserver ()
  "Avvia il devserver di Pelican nella directory public con `make devserver` previa conferma."
  (interactive)
  (let ((public-root (edoc--repo-path "public")))
    (if (file-directory-p public-root)
        (if (yes-or-no-p "ðŸš€ Vuoi avviare il devserver Pelican (`make devserver`)?")
            (let ((default-directory public-root))
              (start-process-shell-command
               "pelican-devserver" "*pelican-devserver*"
               "make devserver")
              (message "âœ… Devserver avviato (vedi buffer *pelican-devserver*)."))
          (message "âŒ Avvio devserver annullato."))
      (message "âš ï¸  Directory public non trovata: %s" public-root))))


(defun edoc-stop-devserver ()
  "Ferma il devserver di Pelican (uccide il processo relativo) previa conferma."
  (interactive)
  (let ((proc (get-process "pelican-devserver")))
    (if proc
        (if (yes-or-no-p "ðŸ›‘ Vuoi fermare il devserver Pelican?")
            (progn
              (kill-process proc)
              (message "ðŸ›‘ Devserver fermato."))
          (message "â¹ Operazione annullata."))
      (message "â„¹ï¸ Nessun devserver attivo trovato."))))

(provide 'edoc-export)
#+END_SRC
  
#+BEGIN_SRC emacs-lisp  :tangle edoc-import.el
;;; edoc-import.el --- Importazione da Markdown a Org -*- lexical-binding: t -*-

(require 'edoc) ;; usa edoc--repo-path e edoc-current-edition-path

(defun edoc-import-markdown ()
  "Importa un file Markdown dal repo pubblico a quello privato come file Org, se non esiste giÃ ."
  (interactive)
  (let* ((public-root (edoc--repo-path "public"))
         (private-root (edoc--repo-path "private"))
         ;; percorso relativo dellâ€™edizione corrente (es. content/2025/summer)
         (relative-path (file-relative-name edoc-current-edition-path private-root))
         (public-dir (expand-file-name relative-path public-root))
         (private-dir (expand-file-name relative-path private-root))
         (file (read-file-name "Importa markdown: " public-dir nil t nil
                               (lambda (f) (string-match "\\.md$" f))))
         (basename (file-name-base file))
         (org-file (expand-file-name (concat basename ".org") private-dir)))
    (if (file-exists-p org-file)
        (message "âš ï¸ Il file %s esiste giÃ  nel repository privato." (file-name-nondirectory org-file))
      (unless (file-directory-p private-dir)
        (make-directory private-dir t))
      (let* ((clean-md (make-temp-file "edoc-md-clean" nil ".md")))
  	;; pulizia iniziale: elimina chiavi tipo YAML
  	(with-temp-buffer
  	  (insert-file-contents file)
  	  (goto-char (point-min))
  	  ;; Rimuove le righe iniziali tipo chiave: valore fino alla prima riga vuota
  	  (while (and (not (eobp))
  		      (looking-at-p "[^[:space:]]+:"))
  	    (kill-whole-line))
  	  ;; Se la riga successiva Ã¨ vuota, toglila pure
  	  (when (looking-at-p "^\\s-*$")
  	    (kill-whole-line))
  	  ;; Scrivi su file temporaneo
  	  (write-region (point-min) (point-max) clean-md))
  	;; Ora lancia pandoc sul file temporaneo pulito

  	;; Aspetta fino a 30 secondi che il file sia leggibile
  	(let ((waited 0))
  	  (while (and (not (file-readable-p clean-md))
  		      (< waited 30))
  	    (sleep-for 0.1)
  	    (setq waited (+ waited 0.1))))

  	(if (not (file-readable-p clean-md))
  	    (message "âŒ File temporaneo non pronto dopo 30 secondi.")
  	  (let ((cmd (format "pandoc -f markdown -t org %s -o %s"
  			     (shell-quote-argument clean-md)
  			     (shell-quote-argument (expand-file-name org-file)))))
  	    (if (= (shell-command cmd) 0)
  		(progn
		   (with-current-buffer (find-file-noselect org-file)
		     (goto-char (point-min))
		     ;; Inserisce le keyword all'inizio del buffer Org
		     (insert "#+OPTIONS: toc:nil\n")
		     (insert "#+ENABLED: yes\n")
		     (insert "#+LOCK: yes\n")
		     (insert "#+STATUS: published\n\n")
		     (save-buffer)
		     (kill-buffer))
  		  (message "âœ… Importato e convertito: %s â†’ %s"
  			   (file-name-nondirectory file)
  			   (file-name-nondirectory org-file))
  		  (sit-for 0.5)
  		  (edoc-dashboard-refresh))
  	      (message "âŒ Errore durante la conversione con pandoc."))))))))

(provide 'edoc-import)
#+END_SRC



#+BEGIN_SRC emacs-lisp  :tangle edoc-import.el
(defun edoc--write-md5-file (paths)
  "Scrive l'MD5 della concatenazione dei contenuti dei file in PATHS in un file nascosto `.nome.md5`.
    Usa il primo file per determinare il nome dell'hash file."
  (when paths
    (let* ((combined
            (mapconcat (lambda (p)
                         (when (file-readable-p p)
                           (with-temp-buffer
                             (insert-file-contents p)
                             (buffer-string))))
                       paths
                       ""))
           (md5-hash (md5 combined))
           (hash-file (concat (file-name-directory (car paths))
                              "." (file-name-nondirectory (car paths))
                              ".md5")))
      (with-temp-file hash-file
        (insert md5-hash))
      hash-file)))

(defun edoc--md5-up-to-date-p (paths)
  "Restituisce t se il contenuto MD5 dei PATHS corrisponde al valore nel file `.nome.md5`."
  (when paths
    (let* ((first-file (car paths))
           (hash-file (concat (file-name-directory first-file)
                              "." (file-name-nondirectory first-file)
                              ".md5")))
      (when (and (file-exists-p hash-file)
                 (file-readable-p hash-file))
        (let* ((actual-md5 (md5 (mapconcat
                                 (lambda (p)
                                   (with-temp-buffer
                                     (insert-file-contents p)
                                     (buffer-string)))
                                 paths "")))
               (stored-md5 (with-temp-buffer
                             (insert-file-contents hash-file)
                             (string-trim (buffer-string)))))
          (string= actual-md5 stored-md5))))))

(defun edoc--org-product-paths (file)
  "Restituisce la lista completa dei path dei file Markdown da produrre per FILE Org.

  Se il file contiene la keyword `#+yPRODUCT:`, i nomi elencati vengono usati.
  Altrimenti viene usato il nome base del file con estensione `.md`, nella directory public."
  (let* ((base (file-name-base file))
         (relpath (file-relative-name edoc-current-edition-path
                                      (edoc--repo-path "private")))
         (target-dir (expand-file-name relpath (edoc--repo-path "public")))
         (product-line (edoc--read-org-keyword-value file "PRODUCT")))
    (if product-line
        ;; Split su virgole e/o spazi, rimuove stringhe vuote
        (let ((names (split-string product-line "[,[:space:]]+" t)))
          (mapcar (lambda (name)
                    (expand-file-name name target-dir))
                  names))
      ;; Default: nome del file .org â†’ .md
      (list (expand-file-name (concat base ".md") target-dir)))))

(defun edoc--read-org-keyword-value (file key)
  "Restituisce il valore della keyword `#+KEY:` nel FILE, oppure nil se assente."
  (when (file-readable-p file)
    (with-temp-buffer
      (insert-file-contents file nil 0 1000)
      (org-mode)
      (goto-char (point-min))
      (when (re-search-forward (concat "^#\\+" (upcase key) ":\\s-*\\(.*\\)$") nil t)
        (string-trim (match-string 1))))))

#+END_SRC
