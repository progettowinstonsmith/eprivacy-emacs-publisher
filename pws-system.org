#+TITLE: PWS – Sistema di pubblicazione EPrivacy
#+AUTHOR: Emmanuele Somma
#+PROPERTY: header-args :tangle no
#+OPTIONS: toc:nil num:nil

* Introduzione

Questo file è il cuore del sistema di pubblicazione PWS (Publishing Workflow System)
per il progetto E-Privacy. Il codice è scritto in Emacs Lisp secondo lo stile 
"literate programming", ed è suddiviso in sezioni modulari che verranno tanglate
in file distinti nella directory dei sorgenti.

Le funzionalità principali comprendono:

- Caricamento delle edizioni e metadati da file `vars.org`
- Analisi e stato dei repository Git (`private`, `public`)
- Visualizzazione testuale interattiva della dashboard
- Comandi per attivare/disattivare/modificare documenti
- Navigazione tra edizioni
- Generazione dei file finali (markdown/org/export)

* edoc-vars.el - Parsing dei file vars.org
#+PROPERTY: header-args:emacs-lisp :tangle edoc-vars.el

Questo modulo si occupa di caricare e analizzare il file `vars.org` contenente i metadati
principali dell’edizione corrente. Restituisce un alist o plist con le informazioni estratte.


#+BEGIN_SRC emacs-lisp :tangle edoc-vars.el
  ;;; edoc-vars.el --- Parsing del file vars.org -*- lexical-binding: t -*-

  (require 'org-element)


  (defun edoc-parse-vars (file)
  "Parsa il file vars.org e restituisce un plist con tutte le keyword #+KEY: e i documenti aggiuntivi."
  (with-temp-buffer
    (insert-file-contents file)
    (org-mode)
    (let* ((parsed (org-element-parse-buffer))
           (vars (edoc--extract-all-keywords parsed))
           (extra-docs (edoc--extract-documents-table parsed)))
      (plist-put vars :extra-documents extra-docs)
      vars)))

  (defun edoc--extract-all-keywords (parsed)
  "Estrae tutte le keyword #+KEY: dal buffer Org come plist, lowercase."
  (let (result)
    (org-element-map parsed 'keyword
      (lambda (el)
        (let* ((key (org-element-property :key el))
               (val (string-trim (org-element-property :value el))))
          (setq result (plist-put result (intern (concat ":" (downcase key))) val)))))
    result))

  (defun edoc--extract-documents-table (parsed)
    "Estrae la tabella 'Documenti aggiuntivi' dal file e restituisce una lista di alist."
    (let ((tables (org-element-map parsed 'table
                    (lambda (tbl)
                      (let ((title (org-element-property :raw-value
                                                         (org-element-lineage tbl '(headline)))))
                        (when (and title (string-match "Documenti aggiuntivi" title))
                          tbl))))))
      (when tables
        (let* ((table (car tables))
               (rows (org-table-to-lisp
                      (org-element-interpret-data table))))
          ;; Rimuove intestazione
          (let ((header (car rows))
                (body (cdr rows)))
            (mapcar (lambda (row)
                      (cl-pairlis (mapcar #'intern (mapcar #'downcase header)) row))
                    body))))))

  (provide 'edoc-vars)
#+END_SRC


* edoc-git.el - Stato dei repository Git
#+PROPERTY: header-args:emacs-lisp :tangle edoc-git.el

Questo modulo gestisce il fetch, lo stato dei branch, l’autore e la data dell’ultimo commit,
e il controllo di divergenza tra locale e remoto per i due repository.


#+BEGIN_SRC emacs-lisp :tangle edoc-git.el
  ;;; edoc-git.el --- Stato Git per PWS -*- lexical-binding: t -*-

  (defun edoc-git-last-commit-summary (repo-path)
    "Restituisce un riassunto dell’ultimo commit nel repository in REPO-PATH."
    (when (file-directory-p repo-path)
      (let ((default-directory repo-path))
        (with-temp-buffer
          (call-process "git" nil t nil "log" "-1" "--pretty=format:%an (%ar)")
          (string-trim (buffer-string))))))

  (defun edoc-git-up-to-date-p (repo-path)
    "Restituisce t se il repository locale è aggiornato rispetto al remoto."
    (when (file-directory-p repo-path)
      (let ((default-directory repo-path))
        (call-process "git" nil nil nil "fetch")
        (with-temp-buffer
          (call-process "git" nil t nil "status" "-uno")
          (goto-char (point-min))
          (not (re-search-forward "Your branch is behind" nil t))))))

  (defun edoc-git-repo-dirty-p (repo-path)
    "Restituisce t se il repository contiene modifiche locali non committate."
    (when (file-directory-p repo-path)
      (let ((default-directory repo-path))
        ;; git diff --quiet restituisce 1 se ci sono modifiche
        (= (call-process "git" nil nil nil "diff" "--quiet") 1))))

  (provide 'edoc-git)
#+END_SRC

* edoc-dashboard.el - Interfaccia testuale
#+PROPERTY: header-args:emacs-lisp :tangle edoc-dashboard.el

Responsabile della visualizzazione dell’interfaccia principale: titolo, repo status,
fase corrente, lista documenti, e informazioni evento.

#+BEGIN_SRC emacs-lisp :tangle edoc-dashboard.el
          ;;; edoc-dashboard.el --- Interfaccia testuale PWS -*- lexical-binding: t -*-

          (require 'edoc-vars)
          (require 'edoc-git)
          (require 'edoc-import)
          (require 'edoc)

        (defun edoc--org-file-status (filepath)
        "Restituisce il valore della proprietà #+STATUS: in FILEPATH, se esiste."
        (when (file-readable-p filepath)
          (with-temp-buffer        
            (insert-file-contents filepath nil 0 1000) ; solo le prime linee
            (org-mode)
            (goto-char (point-min))
            (if (re-search-forward "^#\\+STATUS:\\s-*\\(.*\\)$" nil t)
                (let ((val (string-trim (match-string 1))))
                  (cond
                   ((string-match-p "enabled" val) "✔ enabled")
                   ((string-match-p "draft" val)   "✎ draft")
                   ((string-match-p "disabled" val) "– disattivato")
                   (t val)))
              "– (nessun status)"))))

          (defun edoc--plist-to-alist (plist)
          "Converte un plist in una alist."
          (let (alist)
            (while plist
              (let ((key (car plist))
                    (val (cadr plist)))
                (setq alist (cons (cons key val) alist))
                (setq plist (cddr plist))))
            (nreverse alist)))

        (defun edoc-dashboard-refresh ()
          "Mostra o aggiorna la dashboard."
          (interactive)
          (let* ((edition-path edoc-current-edition-path)
                 (vars-path (expand-file-name "vars.org" edition-path))
                 (data (edoc-parse-vars vars-path))
                 (title (plist-get data :title))
                 (num (or (plist-get data :num)
                          (getenv "EPRIVACY_N")))
                 (fase (or (plist-get data :fase) "setup"))
                 (buf (get-buffer-create "*PWS Dashboard*")))

            (with-current-buffer buf
              (read-only-mode -1)
              (erase-buffer)
              (insert (propertize "PWS EPRIVACY PUBLISHING SYSTEM\n\n" 'face '(:height 1.5 :weight bold)))

              ;; Repo info
              (insert (edoc--dashboard-repo-info "db" (edoc--repo-path "private")))
              (insert (edoc--dashboard-repo-info "site" (edoc--repo-path "public")))

              ;; Edizione corrente
              (insert (format "\nIn lavorazione su: E-PRIVACY %s\n" (or num "??")))
              (insert (format "Fase: %s\n\n" fase))

              ;; Documenti presenti
              (insert (propertize "Documenti presenti nella directory:\n" 'face '(:weight bold)))
              (let* ((doc-files (directory-files edition-path t "\\.org$"))
                     (sorted-docs (sort doc-files #'string<)))
        	(dolist (file sorted-docs)
                  (let* ((name (file-name-nondirectory file))
        		 (status (edoc--org-file-status file)))
        	    (let ((start (point)))
        	      (insert (format "• %-15s %s\n" name status))
        	      (add-text-properties
        	       start (point)
        	       `(edoc-file ,file
        			   mouse-face highlight
        			   help-echo "Premi RET per aprire questo file"))))))



              ;; Variabili in ordine alfabetico (allineate)
              (insert (propertize "\nVariabili definite in vars.org:\n" 'face '(:weight bold)))
              (let* ((exclude '(:extra-documents))
                     (vars (edoc--filtered-vars data exclude))
                     (max-key-len (apply #'max (mapcar (lambda (pair)
        						 (length (symbol-name (car pair))))
                                                       vars))))
        	(dolist (pair vars)
                  (let* ((key (upcase (substring (symbol-name (car pair)) 1)))
        		 (val (cdr pair)))
                    (insert (format (format "%%-%ds : %%s\n" max-key-len) key val)))))

      	(let ((map (make-sparse-keymap)))
      	  (define-key map (kbd "RET") #'edoc-dashboard-open-file-at-point)
      	  (define-key map (kbd "q") #'quit-window)
      	  (define-key map (kbd "g") #'edoc-dashboard-refresh)
    	  (define-key map (kbd "+") #'edoc-dashboard-enable-file)
    	  (define-key map (kbd "-") #'edoc-dashboard-disable-file)
    	  (define-key map (kbd "d") #'edoc-dashboard-toggle-status)
  	  (define-key map (kbd "I") #'edoc-import-markdown)
      	  (use-local-map map))

              (goto-char (point-min))
              (read-only-mode 1)
              (switch-to-buffer buf))))

    (defun edoc-dashboard-toggle-status ()
    "Inverti lo STATUS del file .org sulla riga corrente."
    (interactive)
    (let ((file (get-text-property (point) 'edoc-file))
        (line (line-number-at-pos)))
      (if (not (and file (file-exists-p file)))
          (message "Nessun file .org su questa riga.")
        (let ((current (edoc--get-org-status file)))
          (cond
           ((string= current "enabled")
            (edoc--set-org-status file 'disabled)
            (message "🚫 %s disabilitato." (file-name-nondirectory file)))
           (t
            (edoc--set-org-status file 'enabled)
            (message "✅ %s abilitato." (file-name-nondirectory file))))
          (edoc-dashboard-refresh)                                                                                                                      
  	(edoc--goto-line line)))))

    (defun edoc--get-org-status (filepath)
    "Restituisce il valore di `#+STATUS:` in FILEPATH, o nil se non presente."
    (when (file-readable-p filepath)
      (with-temp-buffer
        (insert-file-contents filepath nil 0 1000)
        (org-mode)
        (goto-char (point-min))
        (when (re-search-forward "^#\\+STATUS:\\s-*\\(.*\\)$" nil t)
          (string-trim (match-string 1))))))


      (defun edoc-dashboard-open-file-at-point ()
      "Apre il file .org associato alla riga corrente nella dashboard, se presente."
      (interactive)
      (let ((file (get-text-property (point) 'edoc-file)))
        (if (and file (file-exists-p file))
            (let ((inhibit-read-only t))
      	(switch-to-buffer (find-file-noselect file)))
          (message "Nessun file .org associato a questa riga."))))

        
          (defun edoc--dashboard-repo-info (label repo-path)
            "Restituisce una stringa con lo stato del repository."
            (let* ((commit (edoc-git-last-commit-summary repo-path))
                   (status (cond
                            ((not (file-directory-p repo-path)) "✖ non presente")
                            ((edoc-git-repo-dirty-p repo-path) "⚠ modifiche locali")
                            ((not (edoc-git-up-to-date-p repo-path)) "↯ non aggiornato")
                            (t "✔ aggiornato"))))
              (format "%-4s v. %s\n      %s\n\n" label (or commit "—") status)))

        (defun edoc--filtered-vars (plist &optional exclude)
        "Ritorna una alist ordinata delle variabili in PLIST, escludendo EXCLUDE."
        (let ((exclude (or exclude '(:extra-documents))))
          (sort
           (cl-remove-if (lambda (pair) (member (car pair) exclude))
                         (edoc--plist-to-alist plist))
           (lambda (a b) (string< (symbol-name (car a))
                                  (symbol-name (car b)))))))


      (defun edoc--set-org-status (file status)
      "Imposta o aggiorna il valore `#+STATUS:` in FILE con STATUS ('enabled, 'disabled, ecc.)."
      (when (file-exists-p file)
        (with-temp-buffer
          (insert-file-contents file)
          (org-mode)
          (goto-char (point-min))
          (if (re-search-forward "^#\\+STATUS:\\s-*\\(.*\\)$" nil t)
              (replace-match (concat "#+STATUS: " (symbol-name status)))
            ;; Se non c'è, inserisci in alto dopo eventuali #+ altre variabili
            (goto-char (point-min))
            (if (re-search-forward "^#\\+" nil t)
                (progn
                  (beginning-of-line)
                  (insert "#+STATUS: " (symbol-name status) "\n"))
              (insert "#+STATUS: " (symbol-name status) "\n")))
          (write-region (point-min) (point-max) file))))

      (defun edoc-dashboard-enable-file ()
      "Abilita il file .org nella riga corrente (STATUS → enabled)."
      (interactive)
      (let ((file (get-text-property (point) 'edoc-file))
        (line (line-number-at-pos)))
        (if file
            (progn
              (edoc--set-org-status file 'enabled)
              (message "✅ %s abilitato." (file-name-nondirectory file))
              (edoc-dashboard-refresh)                                                                                                                      
              (edoc--goto-line line))
          (message "Nessun file .org su questa riga."))))

    (defun edoc-dashboard-disable-file ()
      "Disabilita il file .org nella riga corrente (STATUS → disabled)."
      (interactive)
      (let ((file (get-text-property (point) 'edoc-file))
      (line (line-number-at-pos)))
        (if file
            (progn
              (edoc--set-org-status file 'disabled)
              (message "🚫 %s disabilitato." (file-name-nondirectory file))
              (edoc-dashboard-refresh)
  	    (edoc--goto-line line))
          (message "Nessun file .org su questa riga."))))

  (defun edoc--goto-line (n)
    "Vai alla linea N senza attivare marker."
    (goto-char (point-min))
    (forward-line (1- n)))

          (provide 'edoc-dashboard)
#+END_SRC


* edoc.el - Entry point del sistema
#+PROPERTY: header-args:emacs-lisp :tangle edoc.el

Punto di ingresso del sistema: caricamento pacchetti, definizione di `defcustom` e variabili globali, gestione dell’edizione corrente.


#+BEGIN_SRC emacs-lisp :tangle edoc.el
;;; edoc.el --- Entry point PWS -*- lexical-binding: t -*-

(defgroup edoc nil
  "Sistema di pubblicazione EPrivacy."
  :group 'applications)

(defcustom edoc-current-edition-path "~/production-site/private/content/2025/summer/"
  "Percorso dell’edizione EPrivacy in lavorazione."
  :type 'directory
  :group 'edoc)

(defcustom edoc-repo-private
  "git@github.com-pws:progettowinstonsmith/eprivacy-org-db.git"
  "Repository Git privato contenente i sorgenti Org."
  :type 'string
  :group 'edoc)

(defcustom edoc-repo-public
  "git@github.com-pws:progettowinstonsmith/e-privacy-site.git"
  "Repository Git pubblico contenente il sito generato."
  :type 'string
  :group 'edoc)

(defcustom edoc-production-dir
  "~/production-site"
  "Directory di lavoro contenente i repository clonati."
  :type 'directory
  :group 'edoc)

(defun edoc--repo-path (name)
  "Restituisce il path assoluto di un sotto-repo dentro `production-dir`."
  (expand-file-name name edoc-production-dir))

(defun edoc-clone-repos ()
  "Clona i repository se non esistono già nella `production-dir`."
  (interactive)
  (let ((default-directory edoc-production-dir))
    (unless (file-directory-p edoc-production-dir)
      (make-directory edoc-production-dir t))
    (dolist (repo `(("private" . ,edoc-repo-private)
                    ("public"  . ,edoc-repo-public)))
      (let* ((name (car repo))
             (url (cdr repo))
             (target (edoc--repo-path name)))
        (if (file-directory-p target)
            (message "Repo '%s' già clonato." name)
          (message "Clonazione di '%s' da %s..." name url)
          (call-process "git" nil "*edoc-git*" t "clone" url name)
          (message "✔ Clonato %s in %s" name target))))))

(defun edoc-pull-repos ()
  "Esegue `git pull` nei repository clonati nella production-dir."
  (interactive)
  (dolist (repo-name '("private" "public"))
    (let ((repo-path (edoc--repo-path repo-name)))
      (if (file-directory-p repo-path)
          (let ((default-directory repo-path))
            (message "Aggiornamento repo %s..." repo-name)
            (call-process "git" nil "*edoc-git*" t "pull" "--ff-only")
            (message "✔ Pull completato in %s" repo-path))
        (message "⚠ Repo %s non trovato, forse serve `edoc-clone-repos`?" repo-name)))))

(provide 'edoc)
#+END_SRC


* edoc-import.el - Importazione Markdown → Org
#+PROPERTY: header-args:emacs-lisp :tangle edoc-import.el

Questa sezione definisce una funzione interattiva per importare un file `.md` dal repository pubblico (`public`)
alla directory corrispondente del repository privato (`private`), convertendolo in Org Mode tramite `pandoc`.

L’operazione è sicura: il file `.org` viene generato solo se non esiste già nella destinazione.

#+BEGIN_SRC emacs-lisp  :tangle edoc-import.el
  ;;; edoc-import.el --- Importazione da Markdown a Org -*- lexical-binding: t -*-

  (require 'edoc) ;; usa edoc--repo-path e edoc-current-edition-path

  (defun edoc-import-markdown ()
    "Importa un file Markdown dal repo pubblico a quello privato come file Org, se non esiste già."
    (interactive)
    (let* ((public-root (edoc--repo-path "public"))
           (private-root (edoc--repo-path "private"))
           ;; percorso relativo dell’edizione corrente (es. content/2025/summer)
           (relative-path (file-relative-name edoc-current-edition-path private-root))
           (public-dir (expand-file-name relative-path public-root))
           (private-dir (expand-file-name relative-path private-root))
           (file (read-file-name "Importa markdown: " public-dir nil t nil
                                 (lambda (f) (string-match "\\.md$" f))))
           (basename (file-name-base file))
           (org-file (expand-file-name (concat basename ".org") private-dir)))
      (if (file-exists-p org-file)
          (message "⚠️ Il file %s esiste già nel repository privato." (file-name-nondirectory org-file))
        (unless (file-directory-p private-dir)
          (make-directory private-dir t))
        (let* ((clean-md (make-temp-file "edoc-md-clean" nil ".md")))
  	;; pulizia iniziale: elimina chiavi tipo YAML
  	(with-temp-buffer
  	  (insert-file-contents file)
  	  (goto-char (point-min))
  	  ;; Rimuove le righe iniziali tipo chiave: valore fino alla prima riga vuota
  	  (while (and (not (eobp))
  		      (looking-at-p "[^[:space:]]+:"))
  	    (kill-whole-line))
  	  ;; Se la riga successiva è vuota, toglila pure
  	  (when (looking-at-p "^\\s-*$")
  	    (kill-whole-line))
  	  ;; Scrivi su file temporaneo
  	  (write-region (point-min) (point-max) clean-md))
  	;; Ora lancia pandoc sul file temporaneo pulito

  	;; Aspetta fino a 30 secondi che il file sia leggibile
  	(let ((waited 0))
  	  (while (and (not (file-readable-p clean-md))
  		      (< waited 30))
  	    (sleep-for 0.1)
  	    (setq waited (+ waited 0.1))))

  	(if (not (file-readable-p clean-md))
  	    (message "❌ File temporaneo non pronto dopo 30 secondi.")
  	(let ((cmd (format "pandoc -f markdown -t org %s -o %s"
  			   (shell-quote-argument clean-md)
  			   (shell-quote-argument (expand-file-name org-file)))))
  	  (if (= (shell-command cmd) 0)
  	      (progn
  		(message "✅ Importato e convertito: %s → %s"
  			 (file-name-nondirectory file)
  			 (file-name-nondirectory org-file))
  		(sit-for 0.5)
  		(edoc-dashboard-refresh))
  	    (message "❌ Errore durante la conversione con pandoc."))))))))

  (provide 'edoc-import)
#+END_SRC
