** The =pws-common.el= library
:PROPERTIES:
:CUSTOM_ID: h:3fccfadf-22e9-457f-b9fd-ed1b48600d23
:END:

#+begin_src emacs-lisp :tangle "pws-common.el" :mkdirp yes
;;; pws-common.el --- Common functions for my dotemacs -*- lexical-binding: t -*-

;; Copyright (C) 2020-2025  Protesilaos Stavrou

;; Author: Protesilaos Stavrou <info@protesilaos.com>
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "30.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or (at
;; your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:
;;
;; Common functions for my Emacs: <https://protesilaos.com/emacs/dotemacs/>.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(eval-when-compile
  (require 'subr-x)
  (require 'cl-lib))

(defgroup pws-common ()
  "Auxiliary functions for my dotemacs."
  :group 'editing)

;;;###autoload
(defun pws-common-number-even-p (n)
  "Test if N is an even number."
  (if (numberp n)
      (= (% n 2) 0)
    (error "%s is not a number" n)))

;;;###autoload
(defun pws-common-number-integer-p (n)
  "Test if N is an integer."
  (if (integerp n)
      n
    (error "%s is not an integer" n)))

;;;###autoload
(defun pws-common-number-integer-positive-p (n)
  "Test if N is a positive integer."
  (if (pws-common-number-integer-p n)
      (> n 0)
    (error "%s is not a positive integer" n)))

;; Thanks to Gabriel for providing a cleaner version of
;; `pws-common-number-negative': <https://github.com/gabriel376>.
;;;###autoload
(defun pws-common-number-negative (n)
  "Make N negative."
  (if (and (numberp n) (> n 0))
      (* -1 n)
    (error "%s is not a valid positive number" n)))

;;;###autoload
(defun pws-common-reverse-percentage (number percent change-p)
  "Determine the original value of NUMBER given PERCENT.

CHANGE-P should specify the increase or decrease.  For simplicity,
nil means decrease while non-nil stands for an increase.

NUMBER must satisfy `numberp', while PERCENT must be `natnump'."
  (unless (numberp number)
    (user-error "NUMBER must satisfy numberp"))
  (unless (natnump percent)
    (user-error "PERCENT must satisfy natnump"))
  (let* ((pc (/ (float percent) 100))
         (pc-change (if change-p (+ 1 pc) pc))
         (n (if change-p pc-change (float (- 1 pc-change)))))
    ;; FIXME 2021-12-21: If float, round to 4 decimal points.
    (/ number n)))

;;;###autoload
(defun pws-common-percentage-change (n-original n-final)
  "Find percentage change between N-ORIGINAL and N-FINAL numbers.

When the percentage is not an integer, it is rounded to 4
floating points: 16.666666666666664 => 16.667."
  (unless (numberp n-original)
    (user-error "N-ORIGINAL must satisfy numberp"))
  (unless (numberp n-final)
    (user-error "N-FINAL must satisfy numberp"))
  (let* ((difference (float (abs (- n-original n-final))))
         (n (* (/ difference n-original) 100))
         (round (floor n)))
    ;; FIXME 2021-12-21: Any way to avoid the `string-to-number'?
    (if (> n round) (string-to-number (format "%0.4f" n)) round)))

;; REVIEW 2023-04-07 07:43 +0300: I just wrote the conversions from
;; seconds.  Hopefully they are correct, but I need to double check.
(defun pws-common-seconds-to-minutes (seconds)
  "Convert a number representing SECONDS to MM:SS notation."
  (let ((minutes (/ seconds 60))
        (seconds (% seconds 60)))
    (format "%.2d:%.2d" minutes seconds)))

(defun pws-common-seconds-to-hours (seconds)
  "Convert a number representing SECONDS to HH:MM:SS notation."
  (let* ((hours (/ seconds 3600))
         (minutes (/ (% seconds 3600) 60))
         (seconds (% seconds 60)))
    (format "%.2d:%.2d:%.2d" hours minutes seconds)))

;;;###autoload
(defun pws-common-seconds-to-minutes-or-hours (seconds)
  "Convert SECONDS to either minutes or hours, depending on the value."
  (if (> seconds 3599)
      (pws-common-seconds-to-hours seconds)
    (pws-common-seconds-to-minutes seconds)))

;;;###autoload
(defun pws-common-rotate-list-of-symbol (symbol)
  "Rotate list value of SYMBOL by moving its car to the end.
Return the first element before performing the rotation.

This means that if `sample-list' has an initial value of `(one
two three)', this function will first return `one' and update the
value of `sample-list' to `(two three one)'.  Subsequent calls
will continue rotating accordingly."
  (unless (symbolp symbol)
    (user-error "%s is not a symbol" symbol))
  (when-let* ((value (symbol-value symbol))
              (list (and (listp value) value))
              (first (car list)))
    (set symbol (append (cdr list) (list first)))
    first))

;;;###autoload
(defun pws-common-empty-buffer-p ()
  "Test whether the buffer is empty."
  (or (= (point-min) (point-max))
      (save-excursion
        (goto-char (point-min))
        (while (and (looking-at "^\\([a-zA-Z]+: ?\\)?$")
                    (zerop (forward-line 1))))
        (eobp))))

;;;###autoload
(defun pws-common-minor-modes-active ()
  "Return list of active minor modes for the current buffer."
  (let ((active-modes))
    (mapc (lambda (m)
            (when (and (boundp m) (symbol-value m))
              (push m active-modes)))
          minor-mode-list)
    active-modes))

;;;###autoload
(defun pws-common-truncate-lines-silently ()
  "Toggle line truncation without printing messages."
  (let ((inhibit-message t))
    (toggle-truncate-lines t)))

;; NOTE 2023-08-12: I tried the `clear-message-function', but it did
;; not work.  What I need is very simple and this gets the job done.
;;;###autoload
(defun pws-common-clear-minibuffer-message (&rest _)
  "Print an empty message to clear the echo area.
Use this as advice :after a noisy function."
  (message ""))

;;;###autoload
(defun pws-common-disable-hl-line ()
  "Disable Hl-Line-Mode (for hooks)."
  (hl-line-mode -1))

;;;###autoload
(defun pws-common-window-bounds ()
  "Return start and end points in the window as a cons cell."
  (cons (window-start) (window-end)))

;;;###autoload
(defun pws-common-page-p ()
  "Return non-nil if there is a `page-delimiter' in the buffer."
  (or (save-excursion (re-search-forward page-delimiter nil t))
      (save-excursion (re-search-backward page-delimiter nil t))))

;;;###autoload
(defun pws-common-window-small-p ()
  "Return non-nil if window is small.
Check if the `window-width' or `window-height' is less than
`split-width-threshold' and `split-height-threshold',
respectively."
  (or (and (numberp split-width-threshold)
           (< (window-total-width) split-width-threshold))
      (and (numberp split-height-threshold)
           (> (window-total-height) split-height-threshold))))

(defun pws-common-window-narrow-p ()
  "Return non-nil if window is narrow.
Check if the `window-width' is less than `split-width-threshold'."
  (and (numberp split-width-threshold)
       (< (window-total-width) split-width-threshold)))

;;;###autoload
(defun pws-common-three-or-more-windows-p (&optional frame)
  "Return non-nil if three or more windows occupy FRAME.
If FRAME is non-nil, inspect the current frame."
  (>= (length (window-list frame :no-minibuffer)) 3))

;;;###autoload
(defun pws-common-read-data (file)
  "Read Elisp data from FILE."
  (with-temp-buffer
    (insert-file-contents file)
    (read (current-buffer))))

;;;###autoload
(defun pws-common-completion-category ()
  "Return completion category."
  (when-let* ((window (active-minibuffer-window)))
    (with-current-buffer (window-buffer window)
      (completion-metadata-get
       (completion-metadata (buffer-substring-no-properties
                             (minibuffer-prompt-end)
                             (max (minibuffer-prompt-end) (point)))
                            minibuffer-completion-table
                            minibuffer-completion-predicate)
       'category))))

;; Thanks to Omar Antolín Camarena for providing this snippet!
;;;###autoload
(defun pws-common-completion-table (category candidates)
  "Pass appropriate metadata CATEGORY to completion CANDIDATES.

This is intended for bespoke functions that need to pass
completion metadata that can then be parsed by other
tools (e.g. `embark')."
  (lambda (string pred action)
    (if (eq action 'metadata)
        `(metadata (category . ,category))
      (complete-with-action action candidates string pred))))

;;;###autoload
(defun pws-common-completion-table-no-sort (category candidates)
  "Pass appropriate metadata CATEGORY to completion CANDIDATES.
Like `pws-common-completion-table' but also disable sorting."
  (lambda (string pred action)
    (if (eq action 'metadata)
        `(metadata (category . ,category)
                   (display-sort-function . ,#'identity))
      (complete-with-action action candidates string pred))))

;; Thanks to Igor Lima for the `pws-common-crm-exclude-selected-p':
;; <https://github.com/0x462e41>.
;; This is used as a filter predicate in the relevant prompts.
(defvar crm-separator)

;;;###autoload
(defun pws-common-crm-exclude-selected-p (input)
  "Filter out INPUT from `completing-read-multiple'.
Hide non-destructively the selected entries from the completion
table, thus avoiding the risk of inputting the same match twice.

To be used as the PREDICATE of `completing-read-multiple'."
  (if-let* ((pos (string-match-p crm-separator input))
            (rev-input (reverse input))
            (element (reverse
                      (substring rev-input 0
                                 (string-match-p crm-separator rev-input))))
            (flag t))
      (progn
        (while pos
          (if (string= (substring input 0 pos) element)
              (setq pos nil)
            (setq input (substring input (1+ pos))
                  pos (string-match-p crm-separator input)
                  flag (when pos t))))
        (not flag))
    t))

;; The `pws-common-line-regexp-p' and `pws-common--line-regexp-alist'
;; are contributed by Gabriel: <https://github.com/gabriel376>.  They
;; provide a more elegant approach to using a macro, as shown further
;; below.
(defvar pws-common--line-regexp-alist
  '((empty . "[\s\t]*$")
    (indent . "^[\s\t]+")
    (non-empty . "^.+$")
    (list . "^\\([\s\t#*+]+\\|[0-9]+[^\s]?[).]+\\)")
    (heading . "^[=-]+"))
  "Alist of regexp types used by `pws-common-line-regexp-p'.")

(defun pws-common-line-regexp-p (type &optional n)
  "Test for TYPE on line.
TYPE is the car of a cons cell in
`pws-common--line-regexp-alist'.  It matches a regular
expression.

With optional N, search in the Nth line from point."
  (save-excursion
    (goto-char (line-beginning-position))
    (and (not (bobp))
         (or (beginning-of-line n) t)
         (save-match-data
           (looking-at
            (alist-get type pws-common--line-regexp-alist))))))

;; The `pws-common-shell-command-with-exit-code-and-output' function is
;; courtesy of Harold Carr, who also sent a patch that improved
;; `pws-eww-download-html' (from the `pws-eww.el' library).
;;
;; More about Harold: <http://haroldcarr.com/about/>.
(defun pws-common-shell-command-with-exit-code-and-output (command &rest args)
  "Run COMMAND with ARGS.
Return the exit code and output in a list."
  (with-temp-buffer
    (list (apply 'call-process command nil (current-buffer) nil args)
          (buffer-string))))

(defvar pws-common-url-regexp
  (concat
   "~?\\<\\([-a-zA-Z0-9+&@#/%?=~_|!:,.;]*\\)"
   "[.@]"
   "\\([-a-zA-Z0-9+&@#/%?=~_|!:,.;]+\\)\\>/?")
  "Regular expression to match (most?) URLs or email addresses.")

(autoload 'auth-source-search "auth-source")

;;;###autoload
(defun pws-common-auth-get-field (host prop)
  "Find PROP in `auth-sources' for HOST entry."
  (when-let* ((source (auth-source-search :host host)))
    (if (eq prop :secret)
        (funcall (plist-get (car source) prop))
      (plist-get (flatten-list source) prop))))

;;;###autoload
(defun pws-common-parse-file-as-list (file)
  "Return the contents of FILE as a list of strings.
Strings are split at newline characters and are then trimmed for
negative space.

Use this function to provide a list of candidates for
completion (per `completing-read')."
  (split-string
   (with-temp-buffer
     (insert-file-contents file)
     (buffer-substring-no-properties (point-min) (point-max)))
   "\n" :omit-nulls "[\s\f\t\n\r\v]+"))

(defun pws-common-ignore (&rest _)
  "Use this as override advice to make a function do nothing."
  nil)

;; NOTE 2023-06-02: The `pws-common-wcag-formula' and
;; `pws-common-contrast' are taken verbatim from my `modus-themes'
;; and renamed to have the prefix `pws-common-' instead of
;; `modus-themes-'.  This is all my code, of course, but I do it this
;; way to ensure that this file is self-contained in case someone
;; copies it.

;; This is the WCAG formula: <https://www.w3.org/TR/WCAG20-TECHS/G18.html>.
(defun pws-common-wcag-formula (hex)
  "Get WCAG value of color value HEX.
The value is defined in hexadecimal RGB notation, such #123456."
  (cl-loop for k in '(0.2126 0.7152 0.0722)
           for x in (color-name-to-rgb hex)
           sum (* k (if (<= x 0.03928)
                        (/ x 12.92)
                      (expt (/ (+ x 0.055) 1.055) 2.4)))))

;;;###autoload
(defun pws-common-contrast (c1 c2)
  "Measure WCAG contrast ratio between C1 and C2.
C1 and C2 are color values written in hexadecimal RGB."
  (let ((ct (/ (+ (pws-common-wcag-formula c1) 0.05)
               (+ (pws-common-wcag-formula c2) 0.05))))
    (max ct (/ ct))))

;;;; EXPERIMENTAL macros (not meant to be used anywhere)

;; TODO 2023-09-30: Try the same with `cl-defmacro' and &key
(defmacro pws-common-if (condition &rest consequences)
  "Separate the CONSEQUENCES of CONDITION semantically.
Like `if', `when', `unless' but done by using `:then' and `:else'
keywords.  The forms under each keyword of `:then' and `:else'
belong to the given subset of CONSEQUENCES.

- The absence of `:else' means: (if CONDITION (progn CONSEQUENCES)).
- The absence of `:then' means: (if CONDITION nil CONSEQUENCES).
- Otherwise: (if CONDITION (progn then-CONSEQUENCES) else-CONSEQUENCES)."
  (declare (indent 1))
  (let (then-consequences else-consequences last-kw)
    (dolist (elt consequences)
      (let ((is-keyword (keywordp elt)))
        (cond
         ((and (not is-keyword) (eq last-kw :then))
          (push elt then-consequences))
         ((and (not is-keyword) (eq last-kw :else))
          (push elt else-consequences))
         ((and is-keyword (eq elt :then))
          (setq last-kw :then))
         ((and is-keyword (eq elt :else))
          (setq last-kw :else)))))
    `(if ,condition
         ,(if then-consequences
              `(progn ,@(nreverse then-consequences))
            nil)
       ,@(nreverse else-consequences))))

(provide 'pws-common)
;;; pws-common.el ends here
#+end_src


** The =pws-emacs-org.el= module
:PROPERTIES:
:CUSTOM_ID: h:d799c3c0-bd6a-40bb-bd1a-ba4ea5367840
:END:

# TODO 2024-12-15: Document the pws-org.el clocking commands.

Watch:

- [[https://protesilaos.com/codelog/2023-12-18-emacs-org-advanced-literate-conf/][Advanced literate configuration with Org]] (2023-12-18)
- [[https://protesilaos.com/codelog/2023-05-23-emacs-org-basics/][Basics of Org mode]] (2023-05-23)
- [[https://protesilaos.com/codelog/2021-12-09-emacs-org-block-agenda/][Demo of my custom Org block agenda]] (2021-12-09)
- [[https://protesilaos.com/codelog/2020-02-04-emacs-org-capture-intro/][Primer on "org-capture"]] (2020-02-04)

At its core, Org is a plain text markup language. By "markup
language", we refer to the use of common characters to apply styling,
such as how a word wrapped in asterisks acquires strong emphasis.
Check the video I link to above on the basics of Org mode.

Though what makes Org powerful is not the markup per se, but the fact
that it has a rich corpus of Emacs Lisp code that does a lot with this
otherwise plain text notation. Some of the headline features:

- Cycle the visibility of any heading and its subheadings. This lets
  you quickly fold a section you do not need to see (or reveal the one
  you care about).
- Mix prose with code in a single document to either make the whole
  thing an actual program or to evaluate/demonstrate some snippets.
- Convert ("export") an Org file to a variety of formats, including
  HTML and PDF.
- Use LaTeX inside of Org files to produce a scientific paper without
  all the markup of LaTeX.
- Manage TODO lists and implement a concomitant methodology of
  labelling task states.
- Quickly shift a "thing" (heading, list item, paragraph, ...) further
  up or down in the file.
- Use tables with formulas as a lightweight alternative to spreadsheet
  software.
- Capture data or fleeting thoughts efficiently using templates.
- Maintain an agenda for all your date-bound activities.
- Clock in and out of tasks, to eventually track how you are spending
  your time.
- Link to files regardless of file type. This includes special links
  such as to an Info manual or an email, if you also have that running
  locally and integrated with Emacs ([[#h:755e195b-9471-48c7-963b-33055969b4e2][The =pws-emacs-email.el= module]]).

In other words, Org is highly capable and widely considered one of the
killer apps of Emacs.

This section covers the relevant configurations. You will notice that
it is not limited to Org, as some other built-in features are also
relevant here.

*** The =pws-emacs-org.el= section on the ~calendar~
:PROPERTIES:
:CUSTOM_ID: h:94d48381-1711-4d6b-8449-918bc1e3836c
:END:

The ~calendar~ is technically independent of Org, though it tightly
integrates with it. We witness this when we are setting timestamps,
such as while setting a =SCHEDULED= or =DEADLINE= entry for a given
heading. All I do here is set some stylistic preferences.

Note that Emacs also has a ~diary~ command. I used it for a while, but
Org is far more capable, so I switched to it completely.

#+begin_src emacs-lisp :tangle "pws-emacs-org.el" :mkdirp yes
;;; Calendar  -*- lexical-binding: t; -*-
(use-package calendar
  :ensure nil
  :commands (calendar)
  :config
  (setq calendar-mark-diary-entries-flag nil)
  (setq calendar-mark-holidays-flag t)
  (setq calendar-mode-line-format nil)
  (setq calendar-time-display-form
        '( 24-hours ":" minutes
           (when time-zone (format "(%s)" time-zone))))
  (setq calendar-week-start-day 1)      ; Monday
  (setq calendar-date-style 'iso)
  (setq calendar-time-zone-style 'numeric) ; Emacs 28.1

  (require 'solar)
  (setq calendar-latitude 35.17         ; Not my actual coordinates
        calendar-longitude 33.36)

  (require 'cal-dst)
  (setq calendar-standard-time-zone-name "+0200")
  (setq calendar-daylight-time-zone-name "+0300"))
#+end_src

*** The =pws-emacs-org.el= section about appointment reminders (=appt.el=)
:PROPERTIES:
:CUSTOM_ID: h:bd4b0dcb-a925-4bd7-90db-6379a7ca6f5e
:END:

The built in =appt.el= defines functionality for handling
notifications about appointments. It is originally designed to work
with the generic diary feature (the =M-x diary= one, I mean), which I
do not use anymore, but also integrates nicely with the Org agenda
([[#h:7fe87b83-2815-4617-a5f9-d3417dd9d248][The =pws-emacs-org.el= Org agenda settings]]). I deepen this
integration further, such that after adding a task or changing its
state, the appointments mechanism re-reads my data to register new
notifications. This is done via a series of hooks and with the use of
the advice feature of Emacs Lisp.

Here I am setting some simple settings to keep appointment notifations
minimal. I do not need them to inform me about the contents of my next
entry on the agenda: just show text on the mode line telling me how
many minutes are left until the event.

In Org files, every heading can have an =APPT_WARNTIME= property: it takes
a numeric value representing minutes for a forewarning from =appt.el=.
I use this in tandem with ~org-capture~ for tasks that need to be
done at a specific time, such as coaching sessions ([[#h:f8f06938-0dfe-45c3-b4cf-996d36cba82d][The =pws-emacs-org.el= Org capture templates (~org-capture~)]]).

#+begin_src emacs-lisp :tangle "pws-emacs-org.el"
;;; Appt (appointment reminders which also integrate with Org agenda)
(use-package appt
  :ensure nil
  :commands (appt-activate)
  :config
  (setq appt-display-diary nil
        appt-display-format nil
        appt-display-mode-line t
        appt-display-interval 3
        appt-audible nil ; TODO 2023-01-25: t does nothing because I disable `ring-bell-function'?
        appt-warning-time-regexp "appt \\([0-9]+\\)" ; This is for the diary
        appt-message-warning-time 6)

  (with-eval-after-load 'org-agenda
    (appt-activate 1)

    ;; NOTE 2021-12-07: In my `pws-org.el' (see further below), I add
    ;; `org-agenda-to-appt' to various relevant hooks.
    ;;
    ;; Create reminders for tasks with a due date when this file is read.
    (org-agenda-to-appt)))
#+end_src

*** The =pws-emacs-org.el= section with basic Org settings
:PROPERTIES:
:CUSTOM_ID: h:e03df1e0-b43e-49b5-978e-6a511165617c
:END:

Org, also known as "Org mode", is one of the potentially most useful
feature sets available to every Emacs user. At its core, Org is a
lightweight markup language: you can have headings and paragraphs,
mark a portion of text with emphasis, produce bullet lists, include
code blocks, and the like. Though what really sets Org apart from
other markup languages is the rich corpus of Emacs Lisp written around
it to do all sorts of tasks with this otherwise plain text format.

With Org you can write technical documents (e.g. the manuals of all my
Emacs packages), maintain a simple or highly sophisticated system for
task management, organise your life using the agenda, write tables
that can evaluate formulas to have spreadsheet functionality, have
embedded LaTeX, evaluate code blocks in a wide range of programming
languages and reuse their results for literate programming, include
the contents of other files into a singular file, use one file to
generate other files/directories with all their contents, and export
the Org document to a variety of formats like =.pdf= and =.odt=.
Furthermore, Org can be used as a lightweight, plain text database, as
each heading can have its own metadata. This has practical
applications in most of the aforementioned.

In short, if something can be done with plain text, Org probably does
it already or has all the elements for piecing it together. This
document, among many of my published works, is testament to Org's
sheer power, which I explained at greater length in a video
demonstration: [[https://protesilaos.com/codelog/2023-12-18-emacs-org-advanced-literate-conf/][Advanced literate configuration with Org]] (2023-12-18).

This being Emacs, everything is customisable and Org is a good example
of this. There are a lot of user options for us to tweak things to our
liking. I do as much, though know that Org is perfectly usable without
any configuration. The following sections contain further commentary
on how I use Org.

#+begin_src emacs-lisp :tangle "pws-emacs-org.el"
;;; Org-mode (personal information manager)  -*- lexical-binding: t; -*-
(use-package org
  :ensure nil
  :init
  (setq org-directory (expand-file-name "~/Documents/org/"))
  (setq org-imenu-depth 7)

  (add-to-list 'safe-local-variable-values '(org-hide-leading-stars . t))
  (add-to-list 'safe-local-variable-values '(org-hide-macro-markers . t))
  :bind
  ( :map global-map
    ("C-c l" . org-store-link)
    ("C-c o" . org-open-at-point-global)
    :map org-mode-map
    ;; I don't like that Org binds one zillion keys, so if I want one
    ;; for something more important, I disable it from here.
    ("C-a" . nil)
    ("C-d" . nil)
    ("C-S-d" . nil)
    ("C-'" . nil)
    ("C-," . nil)
    ("M-;" . nil)
    ("<C-return>" . nil)
    ("<C-S-return>" . nil)
    ("C-M-S-<right>" . nil)
    ("C-M-S-<left>" . nil)
    ("C-c ;" . nil)
    ("C-c M-l" . org-insert-last-stored-link)
    ("C-c C-M-l" . org-toggle-link-display)
    ("M-." . org-edit-special) ; alias for C-c ' (mnenomic is global M-. that goes to source)
    :map org-src-mode-map
    ("M-," . org-edit-src-exit) ; see M-. above
    :map narrow-map
    ("b" . org-narrow-to-block)
    ("e" . org-narrow-to-element)
    ("s" . org-narrow-to-subtree)
    :map ctl-x-x-map
    ("i" . pws-org-id-headlines)
    ("r" . pws-org-id-headlines-readable)
    ("h" . pws-org-ox-html))
  :config
  ;; My custom extras, which I use for the agenda and a few other Org features.
  (require 'pws-org)

;;;; general settings
  (setq org-ellipsis "⮧")
  (setq org-special-ctrl-a/e nil)
  (setq org-special-ctrl-k nil)
  (setq org-M-RET-may-split-line '((default . nil)))
  (setq org-hide-emphasis-markers nil)
  (setq org-hide-macro-markers nil)
  (setq org-hide-leading-stars nil)
  (setq org-cycle-separator-lines 0)
  (setq org-structure-template-alist
        '(("s" . "src")
          ("e" . "src emacs-lisp")
          ("E" . "src emacs-lisp :results value code :lexical t")
          ("t" . "src emacs-lisp :tangle FILENAME")
          ("T" . "src emacs-lisp :tangle FILENAME :mkdirp yes")
          ("x" . "example")
          ("X" . "export")
          ("q" . "quote")))
  (setq org-fold-catch-invisible-edits 'show)
  (setq org-return-follows-link nil)
  (setq org-loop-over-headlines-in-active-region 'start-level)
  (setq org-modules '(ol-info ol-eww))
  (setq org-use-sub-superscripts '{})
  (setq org-insert-heading-respect-content t)
  (setq org-read-date-prefer-future 'time)
  (setq org-highlight-latex-and-related nil) ; other options affect elisp regexp in src blocks
  (setq org-fontify-quote-and-verse-blocks t)
  (setq org-fontify-whole-block-delimiter-line t)
  (setq org-track-ordered-property-with-tag t)
  (setq org-highest-priority ?A)
  (setq org-lowest-priority ?C)
  (setq org-default-priority ?A)
  (setq org-priority-faces nil)

  ;; See my `pulsar' package, defined elsewhere in this setup.
  (with-eval-after-load 'pulsar
    (dolist (hook '(org-agenda-after-show-hook org-follow-link-hook))
      (add-hook hook #'pulsar-recenter-center)
      (add-hook hook #'pulsar-reveal-entry))))
#+end_src

*** The =pws-emacs-org.el= Org indent mode settings
:PROPERTIES:
:CUSTOM_ID: h:0c758fca-0a51-4095-9483-b9b0a594333a
:END:

Perhaps the most obvious feature of the Org syntax is the heading
levels. Users can fold them to conceal or reveal only the section of
the document they are interested in. For some documents, such as this
one, where there are lots of deeply nested headings with plenty of
text below them, I find that ~org-indent-mode~ makes it easier for me
to make sense of the contents.

As its name suggests, this minor mode will indent headings and their
text according to their level of depth. This makes it easier to tell
that something belongs to a heading of depth 3 (three asterisks)
instead of two.

The indentation produced by this mode is purely visual though: it does
not actually append tabs or spaces to your file. That is what the user
option ~org-adapt-indentation~ does. For me, I do not want anything to
perform sweeping modifications to my files, as it can easily lead to
mistakes or make things more inconvenient.

Whereas the purely visual ~org-indent-mode~ is a feature we can turn
on and off at will without worrying that something will change in our
file.

I do not set up this minor mode via a hook, as I do not really need it
for small Org files. Instead, I set up the files I am interested in to
have the following somewhere close to the top:

: #+startup: content indent

What this =#+startup= directive does is to (i) show all the headings
while folding their contents and (ii) activate ~org-indent-mode~. If
you add the =#+startup= to an already open file, then you need to do
=M-x org-mode-restart= for changes to take effect.

By default, ~org-indent-mode~ will hide the leading asterisks, keeping
only one at a time. This looks cleaner overall, though I find it
harder to add a new heading as I am not quite sure how many asterisks
I need to add when I perform a manual insertion. Plus, I like seeing
all the leading starts, anyway, in the same way I prefer to have all
the emphasis markers on display. As such, I set the user option
~org-indent-mode-turns-on-hiding-stars~ to ~nil~.

The other small tweak I make is to make the indentation a bit more
pronounced, by setting ~org-indent-indentation-per-level~ to =4=
instead of =2=.

#+begin_src emacs-lisp :tangle "pws-emacs-org.el"
;;;; `org-indent-mode' and related
(use-package org
  :ensure nil
  :config
  (setq org-adapt-indentation nil) ; No, non, nein, όχι to literal indentation!
  (setq org-indent-mode-turns-on-hiding-stars nil)
  (setq org-indent-indentation-per-level 4))
#+end_src

*** The =pws-emacs-org.el= Org to-do and refile settings
:PROPERTIES:
:CUSTOM_ID: h:024dd541-0061-4a10-b10b-b17dcd4794b9
:END:

One of the many use-cases for Org is to maintain a plain text to-do
list. A heading that starts with a to-do keyword, such as =TODO= is
treated as a task and its state is considered not completed.

We can switch between the task states with shift and the left or right
arrow keys. Or we can select a keyword directly with =C-c C-t=, which
calls ~org-todo~ by default. I personally prefer the latter approach,
as it is more precise.

Whenever a task state changes, we can log that event in a special
=LOGBOOK= drawer. This is automatically placed right below the
heading, before any paragraph text. Logging data is an opt-in feature,
which I consider helpful ([[#h:0884658e-9eb5-47e3-9338-66e09004a1a0][The =pws-emacs-org.el= Org time/state logging]]).

Tasks can be associated with timestamps, typically a scheduled
date+time or a deadline+time. This can be helpful when we are
reviewing the source Org file, though it really shines in tandem with
the agenda. Any heading that has a timestamp and which belongs to a
file in the ~org-agenda-files~ will show up on the agenda in the given
date ([[#h:7fe87b83-2815-4617-a5f9-d3417dd9d248][The =pws-emacs-org.el= Org agenda settings]]).

By default, the ~org-todo-keywords~ are =TODO= and =DONE=. We can
write more keywords if we wish to implement a descriptive workflow.
For example, we can have a =WAIT= keyword for something that is to be
done but is not actionable yet. While the number of keywords is not
limited, the binary model is the same: we have words that represent
the incomplete state and those that count as the completion of the
task. For instance, both =CANCEL= and =DONE= mean that the task is not
actionable anymore and we move on to other things. As such, the extra
keywords are a way for the user to make tasks more descriptive and
easy to find. In the value of the ~org-todo-keywords~, we use the bar
character to separate the incomplete state to the left from the
completed one to the right.

One of the agenda's headiline features is the ability to produce a
view that lists headings with the given keyword. So having the right
terms can make search and retrieval of data more easy. On the
flip-side, too many keywords add cognitive load and require more
explicit search terms to yield the desired results. I used to work
with a more descriptive set of keywords, but ultimately decided to
keep things simple.

The refile mechanism is how we can reparent a heading, by moving it
from one place to another. We do this with the command ~org-refile~,
bound to =C-c C-w= by default. A common workflow where refiling is
essential is to have an "inbox" file or heading, where unprocessed
information is stored at, and periodically process its contents to
move the data where it belongs. Though it can also work fine without
any such inbox, in those cases where a heading should be stored
someplace else. The ~org-refile-targets~ specifies the files that are
available when we try to refile the current heading. With how I set it
up, all the agenda files plus the current file's headings up to level
2 are included as possible targets.

In terms of workflow, I have not done a refile in a very long time,
because my entries always stay in the same place as I had envisaged at
the capture phase ([[#h:f8f06938-0dfe-45c3-b4cf-996d36cba82d][The =pws-emacs-org.el= Org capture templates (~org-capture~)]]).

#+begin_src emacs-lisp :tangle "pws-emacs-org.el"
;;;; refile, todo
(use-package org
  :ensure nil
  :config
  (setq org-refile-targets
        '((org-agenda-files . (:maxlevel . 2))
          (nil . (:maxlevel . 2))))
  (setq org-refile-use-outline-path t)
  (setq org-refile-allow-creating-parent-nodes 'confirm)
  (setq org-refile-use-cache t)
  (setq org-reverse-note-order nil)
  ;; ;; NOTE 2023-04-07: Leaving this here for demo purposes.
  ;; (setq org-todo-keywords
  ;;       '((sequence "TODO(t)" "MAYBE(m)" "WAIT(w@/!)" "|" "CANCEL(c@)" "DONE(d!)")
  ;;         (sequence "COACH(k)" "|" "COACHED(K!)")))
  (setq org-todo-keywords
        '((sequence "TODO(t)" "|" "CANCEL(c@)" "DONE(d!)")
          (sequence "COACH(k)" "|" "COACHED(K!)")))

  (defface prot/org-bold-done
    '((t :inherit (bold org-done)))
    "Face for bold DONE-type Org keywords.")

  (setq org-todo-keyword-faces
        '(("CANCEL" . prot/org-bold-done)))
  (setq org-use-fast-todo-selection 'expert)

  (setq org-fontify-done-headline nil)
  (setq org-fontify-todo-headline nil)
  (setq org-fontify-whole-heading-line nil)
  (setq org-enforce-todo-dependencies t)
  (setq org-enforce-todo-checkbox-dependencies t))
#+end_src

*** The =pws-emacs-org.el= Org heading tags
:PROPERTIES:
:CUSTOM_ID: h:81de4e32-a1af-4e1f-9e10-90eb0c90afa2
:END:

Each Org heading can have one or more tags associated with it, while
all headings inherit any potential =#+FILETAGS=. We can add tags to a
heading when the cursor is over it by typing the ever flexible =C-c C-c=.
Though the more specific ~org-set-tags-command~ also gets the job
done, plus it does not require that the cursor is positioned on the
heading text.

Tagging is useful for searching and retrieving the data we store. The
Org agenda, in particular, provides commands to filter tasks by tag:

- [[#h:024dd541-0061-4a10-b10b-b17dcd4794b9][The =pws-emacs-org.el= Org to-do and refile settings]]
- [[#h:7fe87b83-2815-4617-a5f9-d3417dd9d248][The =pws-emacs-org.el= Org agenda settings]]

The user option ~org-tag-alist~ lets us specify tags we always want to
use, though we can write tags per file as well by using the =#+TAGS=
keyword. I do the latter as a global list of tags is not useful in my
case. For example, when I wan checking my =coach.org= file for the
coaching sessions I provide, I do not need to see any of the tags that
make sense in my general =tasks.org=.

Note that in the settings below I disable the auto-alignment that Org
does where it shifts tags to the right of the heading. I do not like
it.

#+begin_src emacs-lisp :tangle "pws-emacs-org.el"
;;;; tags
(use-package org
  :ensure nil
  :config
  (setq org-tag-alist nil)
  (setq org-auto-align-tags nil)
  (setq org-tags-column 0))
#+end_src

*** The =pws-emacs-org.el= Org time/state logging
:PROPERTIES:
:CUSTOM_ID: h:0884658e-9eb5-47e3-9338-66e09004a1a0
:END:

Org can keep a record of state changes, such as when we set an entry
marked with the =TODO= keyword as =DONE= or when we reschedule an
appointment ([[#h:7fe87b83-2815-4617-a5f9-d3417dd9d248][The =pws-emacs-org.el= Org agenda settings]]). This data
is stored in a =LOGBOOK= drawer right below the heading. I choose to
keep track of this information, as it is sometimes useful to capture
mistakes or figure out intent in the absence of further clarification
(though I do tend to write why something happened).

#+begin_src emacs-lisp :tangle "pws-emacs-org.el"
;;;; log
(use-package org
  :ensure nil
  :config
  (setq org-log-done 'time)
  (setq org-log-into-drawer t)
  (setq org-log-note-clock-out nil)
  (setq org-log-redeadline 'time)
  (setq org-log-reschedule 'time))
#+end_src

*** The =pws-emacs-org.el= Org link settings
:PROPERTIES:
:CUSTOM_ID: h:da8ce883-7f21-4a6e-a41f-d668ad762b41
:END:

One of the nice things about Org is its flexible linking mechanism. It
can produce links to a variety of file types or buffers and even
navigate to a section therein.

At its simplest form, we have the =file= link type, which points to a
file system path, with an optional extension for a match inside the
file, as documented in the manual. Evaluate this inside of Emacs:

#+begin_example emacs-lisp
(info "(org) Search Options")
#+end_example

Links to buffers are also common and valuable. For example, we can
have a link to a page produced by the ~man~ command, which gives us
quick access to the documentation of some program. When Org follows
that link, it opens the buffer in the appropriate major mode. For me,
the most common scenario is a link to an email, which I typically
associate with a task that shows up in my agenda:

- [[#h:f8f06938-0dfe-45c3-b4cf-996d36cba82d][The =pws-emacs-org.el= Org capture templates (~org-capture~)]]
- [[#h:49890997-448e-408d-bebe-2003259bb125][The =pws-emacs-notmuch.el= glue code for ~org-capture~ (=ol-notmuch.el=)]]

Org supports lots of link types out-of-the-box, though more can be
added by packages. My Denote does this: it defines a =denote= link
type which behaves the same way as the =file= type except that it uses
the identifier of the file instead of its full path (so eve if the
file is renamed, the link will work for as long as the identifier
remains the same).

Links can be generated automatically as part of an ~org-capture~
template. The command ~org-store-link~ produces one manually, storing
it to a special data structure from which it can be retrieved later
for insertion with the command ~org-insert-link~. The latter command
can also create new links, simply by receiving data that is different
from what was already stored.

I bind ~org-store-link~ in main section of the Org configuration:
[[#h:e03df1e0-b43e-49b5-978e-6a511165617c][The =pws-emacs-org.el= section with basic Org settings]].

#+begin_src emacs-lisp :tangle "pws-emacs-org.el"
;;;; links
(use-package org
  :ensure nil
  :config
  (require 'pws-org) ; for the above commands

  (setq org-link-context-for-files t)
  (setq org-link-keep-stored-after-insertion nil)
  (setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id))
#+end_src

*** The =pws-emacs-org.el= Org code block settings
:PROPERTIES:
:CUSTOM_ID: h:1f5a0d46-5202-48dd-8048-b48ce17f3df8
:END:

This document benefits from Org's ability to combine prose with code,
by placing the latter inside of a block that is delimited by
=#+BEGIN_SRC= and =#+END_SRC= lines.

Code blocks can use the syntax highlighting ("fontification" in Emacs
parlance) of a given major mode. They can also have optional
parameters passed to their header, which expand the capabilities of
the block. For instance, the following code block with my actual
configuration uses the fontification of the ~emacs-lisp-mode~ and has
a =:tangle= parameter with a value of a file system path. When I
invoke the command ~org-babel-tangle~, the contents of this block will
be added to that file, creating the file if necessary.

More generally, Org is capable of evaluating code blocks and passing
their return value to other code blocks. It is thus possible to write
a fully fledged program as an Org document. This paradigm is known as
"literate programming". In the case of an Emacs configuration, such as
mine, it is called a "literate configuration" or variants thereof. I
did a video about my setup: [[https://protesilaos.com/codelog/2023-12-18-emacs-org-advanced-literate-conf/][Advanced literate configuration with Org]] (2023-12-18).

Org can evaluate code blocks in many languages. This is known as "Org
Babel" and the files which implement support for a given language are
typically named =ob-LANG.el= where =LANG= is the name of the language.
We can load the requisite code for the languages we care about with
something like the following:

#+begin_example emacs-lisp
(require 'ob-python)

;; OR

(use-package ob-python)

;; OR for more control

(use-package ob-python
  :after org
  :config
  ;; Settings here
  )
#+end_example

I seldom need to work with Org Babel, so I do not load any language
automatically. Note that Emacs Lisp is loaded by default.

To evaluate a code block, we type Org's omnipotent =C-c C-c=. The
results will be produced below the code block. There is an optional
parameter that controls how---or even if---the results are displayed.

There are many other types of block apart from =SRC=. Those do
different things, such as:

- =#+BEGIN_QUOTE= :: Treat the contents as a block quote or equivalent.
- =#+BEGIN_VERSE= :: Do not reflow any like breaks (for poetry and such).
- =#+BEGIN_EXPORT= :: Evaluate the code for the given export target
  (like =html= or =latex=), optionally replacing it with its results
  or keeping both of them ([[#h:bd11d4d8-6e9f-4536-87a4-4018783bf8f5][The =pws-emacs-org.el= Org export settings]]).

This is a wonderful world of possibilities!

#+begin_src emacs-lisp :tangle "pws-emacs-org.el"
;;;; code blocks
(use-package org
  :ensure nil
  :config
  (setq org-confirm-babel-evaluate nil)
  (setq org-src-window-setup 'current-window)
  (setq org-edit-src-persistent-message nil)
  (setq org-src-fontify-natively t)
  (setq org-src-preserve-indentation t)
  (setq org-src-tab-acts-natively t)
  (setq org-edit-src-content-indentation 0))
#+end_src

*** The =pws-emacs-org.el= Org export settings
:PROPERTIES:
:CUSTOM_ID: h:bd11d4d8-6e9f-4536-87a4-4018783bf8f5
:END:

Org is a capable authoring tool in no small part because it can be
converted to other file formats. A typical example is to write a
technical document in Org and then export it to a PDF. Another
use-case is what I commonly do with the Emacs packages I maintain,
which I export to an Info manual (texinfo format) and an HTML web
page.

The default set of export targets is specified in the value of the
user option ~org-export-backends~. It is one of those rare cases where
it has to be evaluated before the package is loaded. Other than that,
we can load an export backend by finding the correspond =ox-FORMAT.el=
file and either ~require~ it or load it with ~use-package~, like what
I showed for Org Babel ([[#h:1f5a0d46-5202-48dd-8048-b48ce17f3df8][The =pws-emacs-org.el= Org code block settings]]).

#+begin_src emacs-lisp :tangle "pws-emacs-org.el"
;;;; export
(use-package org
  :ensure nil
  :init
  ;; NOTE 2023-05-20: Must be evaluated before Org is loaded,
  ;; otherwise we have to use the Custom UI.  No thanks!
  (setq org-export-backends '(html texinfo md))
  :config
  (setq org-export-with-toc t)
  (setq org-export-headline-levels 8)
  (setq org-export-dispatch-use-expert-ui nil)
  (setq org-html-htmlize-output-type nil)
  (setq org-html-head-include-default-style nil)
  (setq org-html-head-include-scripts nil))
#+end_src

*** The =pws-emacs-org.el= Org capture templates (~org-capture~)
:PROPERTIES:
:CUSTOM_ID: h:f8f06938-0dfe-45c3-b4cf-996d36cba82d
:END:

The ~org-capture~ command allows us to quickly store data in some
structured way. This is done with the help of a templating system
where we can, for example, record the date the entry was recorded,
prompt for user input, automatically use the email's subject as the
title of the task, and the like. The documentation string of
~org-capture-templates~ covers the technicalities.

I use two Org files for my tasks. The one is =tasks.org=, which
contains the bulk of my entries. The other is =coach.org=, which is
specific to my coaching work: https://protesilaos.com/coach.

The =tasks.org= consists of several top-level headings. Each contains
subheadings I need to review. You will notice how most of my
entries in ~org-capture-templates~ involve this file. With Org, it is
perfectly fine to work in a single file because we can fold headings
or narrow to them with ~org-narrow-to-subtree~. Furthermore, we can
navigate directly to a heading using minibuffer completion, such as
with the general purpose command ~pws-search-outline~
([[#h:b902e6a3-cdd2-420f-bc99-3d973c37cd20][The =pws-emacs-search.el= extras provided by the =pws-search.el= library]]).

Despite the fact that Org copes well with large files, I still choose
to keep my coaching work in a separate file as a contingency plan.
Because =coach.org= includes information about appointments, I need to
be able to read it with ease from anywhere. This includes different
types of hardware, but also any kind of generic text editor or
terminal pager. I do not want to depend on features like folding,
narrowing, and the like, in times when something has gone awry.
Granted, this has never happened, though the idea makes sense.
Besides, two files are not hard to manage in this case. The
=coach.org= has a simple structure: each appointment is stored as a
top-level heading.

As for my workflow, here is an overview:

- When I want to capture data that I am not yet sure about, I add it
  to the =tasks.org= "Unprocessed" heading. I periodically review
  those to decide if I want to do something with them or not. If I do
  not want them, I delete them. Otherwise, I file them under another
  heading in the same file using the ~org-refile~ command ([[#h:024dd541-0061-4a10-b10b-b17dcd4794b9][The =pws-emacs-org.el= Org to-do and refile settings]]).
  Not everything goes into the "Unprocessed" headings, as I often
  known in advance what an item is about. This is just a fallback for
  those cases when I need more information to decide on the
  appropriate action.

- Tasks that have an inherent time component are given a =SCHEDULED=
  or =DEADLINE= timestamp (set those on demand with the commands
  ~org-schedule~ and ~org-deadline~, respectively). These are the only
  tasks I want to see on my daily agenda ([[#h:7fe87b83-2815-4617-a5f9-d3417dd9d248][The =pws-emacs-org.el= Org agenda settings]]).
  The difference between =SCHEDULED= and =DEADLINE= is that the former
  has no strict start or end time and so is flexible, while the latter
  is more rigid. For example, "visit the vet today" does not have a
  strict time associated with it because the doctor often deals with
  emergency situations and thus their agenda is fluid. While a
  coaching session of mine like "work on Emacs with PERSON" has to
  start at the agreed upon time.

- I do not arbitrarily assign timestamps to tasks. If something does
  not have a scheduled date or a deadline, then it does not belong on
  the agenda. Otherwise, those arbitrarily defined "events" accumulate
  in the agenda and crowd out the actual time-sensitive tasks. As a
  result, the cognitive load is heavier and things will not be done.
  So when I want to do something at some point, but have no specific
  plan for it, I add is to the =tasks.org= "Wishlist". When I have
  free time, I review my wishlist and pick something to work on from
  there depending on my available time and mood. This keeps my
  workflow both focused and stress-free.

- Finally, my =coach.org= only has time-sensitive appointments with a
  =DEADLINE= associated with them. I organise the rest of my
  activities in the given day based on those.

#+begin_src emacs-lisp :tangle "pws-emacs-org.el"
;;;; capture
(use-package org-capture
  :ensure nil
  :bind ("C-c c" . org-capture)
  :config
  (require 'pws-org)

  (setq org-capture-templates
        `(("u" "Unprocessed" entry
           (file+headline "tasks.org" "Unprocessed")
           ,(concat "* %^{Title}\n"
                    ":PROPERTIES:\n"
                    ":CAPTURED: %U\n"
                    ":CUSTOM_ID: h:%(format-time-string \"%Y%m%dT%H%M%S\")\n"
                    ":END:\n\n"
                    "%a\n%i%?")
           :empty-lines-after 1)
          ("w" "Wishlist" entry
           (file+olp "tasks.org" "All tasks" "Wishlist")
           ,(concat "* %^{Title} %^g\n"
                    ":PROPERTIES:\n"
                    ":CAPTURED: %U\n"
                    ":CUSTOM_ID: h:%(format-time-string \"%Y%m%dT%H%M%S\")\n"
                    ":END:\n\n"
                    "%a\n%?")
           :empty-lines-after 1)
          ("t" "Task to do" entry
           (file+headline "tasks.org" "All tasks")
           ,(concat "* TODO %^{Title} %^g\n"
                    ":PROPERTIES:\n"
                    ":CAPTURED: %U\n"
                    ":CUSTOM_ID: h:%(format-time-string \"%Y%m%dT%H%M%S\")\n"
                    ":END:\n\n"
                    "%a\n%?")
           :empty-lines-after 1)
          ("s" "Select file and heading to add to" entry
           (function pws-org-select-heading-in-file)
           ,(concat "* TODO %^{Title}%?\n"
                    ":PROPERTIES:\n"
                    ":CAPTURED: %U\n"
                    ":CUSTOM_ID: h:%(format-time-string \"%Y%m%dT%H%M%S\")\n"
                    ":END:\n\n")
           :empty-lines-after 1)

          ;; NOTE 2024-11-24: I am not using this, but am keeping it
          ;; here because the approach is good.

          ;; ("c" "Clock in and do immediately" entry
          ;;  (file+headline "tasks.org" "Clocked tasks")
          ;;  ,(concat "* TODO %^{Title}\n"
          ;;           ":PROPERTIES:\n"
          ;;           ":EFFORT: %^{Effort estimate in minutes|5|10|15|30|45|60|90|120}\n"
          ;;           ":END:\n\n"
          ;;           "%a\n")
          ;;  :prepend t
          ;;  :clock-in t
          ;;  :clock-keep t
          ;;  :immediate-finish t
          ;;  :empty-lines-after 1)
          ("p" "Private lesson or service" entry
           (file "coach.org")
           #'pws-org-capture-coach
           :prepend t
           :empty-lines 1)
          ("P" "Private service clocked" entry
           (file+headline "coach.org" "Clocked services")
           #'pws-org-capture-coach-clock
           :prepend t
           :clock-in t
           :clock-keep t
           :immediate-finish t
           :empty-lines 1)))

  ;; NOTE 2024-11-10: I realised that I was not using this enough, so
  ;; I decided to simplify my setup.  Keeping it here, in case I need
  ;; it again.

  ;; (setq org-capture-templates-contexts
  ;;       '(("e" ((in-mode . "notmuch-search-mode")
  ;;               (in-mode . "notmuch-show-mode")
  ;;               (in-mode . "notmuch-tree-mode")))))
  )
#+end_src

*** The =pws-emacs-org.el= Org agenda settings
:PROPERTIES:
:CUSTOM_ID: h:7fe87b83-2815-4617-a5f9-d3417dd9d248
:END:

[ Watch: [[https://protesilaos.com/codelog/2021-12-09-emacs-org-block-agenda/][Demo of my custom Org block agenda]] (2021-12-09). It has
  changed a bit since then, but the idea is the same. ]

With the Org agenda, we can visualise the tasks we have collected in
our Org files or, more specifically, in the list of files specified in
the user option ~org-agenda-files~. In my workflow, only the files in
the ~org-directory~ can feed data into the agenda. Though Org provides
commands to add/remove the current file on demand: ~org-remove-file~,
and ~org-agenda-file-to-front~. If I ever need to write a task that is
specific to a certain file or buffer, then I use Org's linking
mechanism to point to the relevant context, but otherwise store my
task in the usual place ([[#h:f8f06938-0dfe-45c3-b4cf-996d36cba82d][The =pws-emacs-org.el= Org capture templates (~org-capture~)]]).

By default, Org provides many so-called "views" for the agenda. One of
the them is the daily/weekly agenda. Others show only the headings
with =TODO= keywords, or some other kind of search criteria. I
personally never use those views. I have my own custom agenda view,
which consolidates in a single buffer the following blocks on data, in
this order ([[#h:9974eac8-2167-45c4-90e0-12dd877403da][The =pws-org.el= library]]).:

- Important tasks without a date :: When I add a top priority to
  something, but there is no inherent deadline to it.

- Pending scheduled tasks :: Tasks with a =SCHEDULED= date may
  sometimes not be done when they ought to. So they need to be closer
  to the top for me to do them as soon as I can.

- Today's agenda :: What I am actually working on. Because I only
  assign a timestamp to tasks that are indeed time-sensitive, this
  always reflects the commitments I have for the day.

- Next three days :: Like the above, but for the near future.

- Upcoming deadlines (+14d) :: These are the deadlines I need to be
  aware of for the 14 days after the next three days I am only
  informed about.

The Org agenda has lots of other extras, such as to filter the view.
Though I never use them. My custom agenda does exactly what I need
from it and thus keeps me focused.

#+begin_src emacs-lisp :tangle "pws-emacs-org.el"
;;;; agenda
(use-package org-agenda
  :ensure nil
  :bind
  ;; I bind `org-agenda' to C-c A, so this one puts me straight into my
  ;; custom block agenda.
  ( :map global-map
    ("C-c A" . org-agenda)
    ("C-c a" . (lambda ()
                 "Call Org agenda with `pws-org-custom-daily-agenda' configuration."
                 (interactive)
                 (org-agenda nil "A"))))
  :config
;;;;; Custom agenda blocks

  (setq org-agenda-format-date #'pws-org-agenda-format-date-aligned)

  ;; Check the variable `pws-org-custom-daily-agenda' in pws-org.el
  (setq org-agenda-custom-commands
        `(("A" "Daily agenda and top priority tasks"
           ,pws-org-custom-daily-agenda
           ((org-agenda-fontify-priorities nil)
            (org-agenda-prefix-format "	 %t %s")
            (org-agenda-dim-blocked-tasks nil)))
          ("P" "Plain text daily agenda and top priorities"
           ,pws-org-custom-daily-agenda
           ((org-agenda-with-colors nil)
            (org-agenda-prefix-format "%t %s")
            (org-agenda-current-time-string ,(car (last org-agenda-time-grid)))
            (org-agenda-fontify-priorities nil)
            (org-agenda-remove-tags t))
           ("agenda.txt"))))

;;;;; Basic agenda setup
  (setq org-default-notes-file (make-temp-file "emacs-org-notes-")) ; send it to oblivion
  (setq org-agenda-files `(,org-directory))
  (setq org-agenda-span 'week)
  (setq org-agenda-start-on-weekday 1)  ; Monday
  (setq org-agenda-confirm-kill t)
  (setq org-agenda-show-all-dates t)
  (setq org-agenda-show-outline-path nil)
  (setq org-agenda-window-setup 'current-window)
  (setq org-agenda-skip-comment-trees t)
  (setq org-agenda-menu-show-matcher t)
  (setq org-agenda-menu-two-columns nil)
  (setq org-agenda-sticky nil)
  (setq org-agenda-custom-commands-contexts nil)
  (setq org-agenda-max-entries nil)
  (setq org-agenda-max-todos nil)
  (setq org-agenda-max-tags nil)
  (setq org-agenda-max-effort nil)

;;;;; General agenda view options
  ;; NOTE 2021-12-07: Check further below my `org-agenda-custom-commands'
  (setq org-agenda-prefix-format
        '((agenda . " %i %-12:c%?-12t% s")
          (todo . " %i %-12:c")
          (tags . " %i %-12:c")
          (search . " %i %-12:c")))
  (setq org-agenda-sorting-strategy
        '(((agenda habit-down time-up priority-down category-keep)
           (todo priority-down category-keep)
           (tags priority-down category-keep)
           (search category-keep))))
  (setq org-agenda-breadcrumbs-separator "->")
  (setq org-agenda-todo-keyword-format "%-1s")
  (setq org-agenda-fontify-priorities 'cookies)
  (setq org-agenda-category-icon-alist nil)
  (setq org-agenda-remove-times-when-in-prefix nil)
  (setq org-agenda-remove-timeranges-from-blocks nil)
  (setq org-agenda-compact-blocks nil)
  (setq org-agenda-block-separator ?—)

;;;;; Agenda marks
  (setq org-agenda-bulk-mark-char "#")
  (setq org-agenda-persistent-marks nil)

;;;;; Agenda diary entries
  (setq org-agenda-insert-diary-strategy 'date-tree)
  (setq org-agenda-insert-diary-extract-time nil)
  (setq org-agenda-include-diary nil)
  ;; I do not want the diary, but there is no way to disable it
  ;; altogether.  This creates a diary file in the /tmp directory.
  (setq diary-file (make-temp-file "emacs-diary-"))
  (setq org-agenda-diary-file 'diary-file) ; TODO 2023-05-20: review Org diary substitute

;;;;; Agenda follow mode
  (setq org-agenda-start-with-follow-mode nil)
  (setq org-agenda-follow-indirect t)

;;;;; Agenda multi-item tasks
  (setq org-agenda-dim-blocked-tasks t)
  (setq org-agenda-todo-list-sublevels t)

;;;;; Agenda filters and restricted views
  (setq org-agenda-persistent-filter nil)
  (setq org-agenda-restriction-lock-highlight-subtree t)

;;;;; Agenda items with deadline and scheduled timestamps
  (setq org-agenda-include-deadlines t)
  (setq org-deadline-warning-days 0)
  (setq org-agenda-skip-scheduled-if-done nil)
  (setq org-agenda-skip-scheduled-if-deadline-is-shown t)
  (setq org-agenda-skip-timestamp-if-deadline-is-shown t)
  (setq org-agenda-skip-deadline-if-done nil)
  (setq org-agenda-skip-deadline-prewarning-if-scheduled 1)
  (setq org-agenda-skip-scheduled-delay-if-deadline nil)
  (setq org-agenda-skip-additional-timestamps-same-entry nil)
  (setq org-agenda-skip-timestamp-if-done nil)
  (setq org-agenda-search-headline-for-time nil)
  (setq org-scheduled-past-days 365)
  (setq org-deadline-past-days 365)
  (setq org-agenda-move-date-from-past-immediately-to-today t)
  (setq org-agenda-show-future-repeats t)
  (setq org-agenda-prefer-last-repeat nil)
  (setq org-agenda-timerange-leaders
        '("" "(%d/%d): "))
  (setq org-agenda-scheduled-leaders
        '("Scheduled: " "Sched.%2dx: "))
  (setq org-agenda-inactive-leader "[")
  (setq org-agenda-deadline-leaders
        '("Deadline:  " "In %3d d.: " "%2d d. ago: "))
  ;; Time grid
  (setq org-agenda-time-leading-zero t)
  (setq org-agenda-timegrid-use-ampm nil)
  (setq org-agenda-use-time-grid t)
  (setq org-agenda-show-current-time-in-grid t)
  (setq org-agenda-current-time-string (concat "Now " (make-string 70 ?.)))
  (setq org-agenda-time-grid
        '((daily today require-timed)
          ( 0500 0600 0700 0800 0900 1000
            1100 1200 1300 1400 1500 1600
            1700 1800 1900 2000 2100 2200)
          "" ""))
  (setq org-agenda-default-appointment-duration nil)

;;;;; Agenda global to-do list
  (setq org-agenda-todo-ignore-with-date t)
  (setq org-agenda-todo-ignore-timestamp t)
  (setq org-agenda-todo-ignore-scheduled t)
  (setq org-agenda-todo-ignore-deadlines t)
  (setq org-agenda-todo-ignore-time-comparison-use-seconds t)
  (setq org-agenda-tags-todo-honor-ignore-options nil)

;;;;; Agenda tagged items
  (setq org-agenda-show-inherited-tags t)
  (setq org-agenda-use-tag-inheritance
        '(todo search agenda))
  (setq org-agenda-hide-tags-regexp nil)
  (setq org-agenda-remove-tags nil)
  (setq org-agenda-tags-column -100)

;;;;; Agenda entry
  ;; NOTE: I do not use this right now.  Leaving everything to its
  ;; default value.
  (setq org-agenda-start-with-entry-text-mode nil)
  (setq org-agenda-entry-text-maxlines 5)
  (setq org-agenda-entry-text-exclude-regexps nil)
  (setq org-agenda-entry-text-leaders "    > ")

;;;;; Agenda logging and clocking
  ;; NOTE: I do not use these yet, though I plan to.  Leaving everything
  ;; to its default value for the time being.
  (setq org-agenda-log-mode-items '(closed clock))
  (setq org-agenda-clock-consistency-checks
        '((:max-duration "10:00" :min-duration 0 :max-gap "0:05" :gap-ok-around
                         ("4:00")
                         :default-face ; This should definitely be reviewed
                         ((:background "DarkRed")
                          (:foreground "white"))
                         :overlap-face nil :gap-face nil :no-end-time-face nil
                         :long-face nil :short-face nil)))
  (setq org-agenda-log-mode-add-notes t)
  (setq org-agenda-start-with-log-mode nil)
  (setq org-agenda-start-with-clockreport-mode nil)
  (setq org-agenda-clockreport-parameter-plist '(:link t :maxlevel 2))
  (setq org-agenda-search-view-always-boolean nil)
  (setq org-agenda-search-view-force-full-words nil)
  (setq org-agenda-search-view-max-outline-level 0)
  (setq org-agenda-search-headline-for-time t)
  (setq org-agenda-use-time-grid t)
  (setq org-agenda-cmp-user-defined nil)
  (setq org-agenda-sort-notime-is-late t) ; Org 9.4
  (setq org-agenda-sort-noeffort-is-high t) ; Org 9.4

;;;;; Agenda column view
  ;; NOTE I do not use these, but may need them in the future.
  (setq org-agenda-view-columns-initially nil)
  (setq org-agenda-columns-show-summaries t)
  (setq org-agenda-columns-compute-summary-properties t)
  (setq org-agenda-columns-add-appointments-to-effort-sum nil)
  (setq org-agenda-auto-exclude-function nil)
  (setq org-agenda-bulk-custom-functions nil)

  ;; ;;;;; Agenda habits
  ;;   (require 'org-habit)
  ;;   (setq org-habit-graph-column 50)
  ;;   (setq org-habit-preceding-days 9)
  ;;   ;; Always show the habit graph, even if there are no habits for
  ;;   ;; today.
  ;;   (setq org-habit-show-all-today t)
  )
#+end_src

*** The =pws-emacs-org.el= call to ~provide~
:PROPERTIES:
:CUSTOM_ID: h:62eb7ca3-2f79-45a6-a018-38238b486e98
:END:

Finally, we ~provide~ the module. This is the mirror function of
~require~ ([[#h:e6c4acf5-5b51-4b38-a86a-bf3f698ac872][The init.el final part to load the individual modules]]).

#+begin_src emacs-lisp :tangle "pws-emacs-org.el"
(provide 'pws-emacs-org)
#+end_src


** The =pws-org.el= library

:PROPERTIES:
:CUSTOM_ID: h:9974eac8-2167-45c4-90e0-12dd877403da
:END:

#+begin_src emacs-lisp :tangle "pws-org.el" :mkdirp yes
;;; pws-org.el --- Tweaks for my org-mode configurations -*- lexical-binding: t -*-

;; Copyright (C) 2021-2025  Protesilaos Stavrou

;; Author: Protesilaos Stavrou <info@protesilaos.com>
;; URL: https://protesilaos.com/emacs/dotemacs
;; Version: 0.1.0
;; Package-Requires: ((emacs "30.1"))

;; This file is NOT part of GNU Emacs.

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:
;;
;; This covers my tweaks for Org that are meant for use in my
;; Emacs setup: https://protesilaos.com/emacs/dotemacs.
;;
;; Remember that every piece of Elisp that I write is for my own
;; educational and recreational purposes.  I am not a programmer and I
;; do not recommend that you copy any of this if you are not certain of
;; what it does.

;;; Code:

(require 'pws-common)
(require 'org)

(defgroup pws-org ()
  "Extensions for org.el."
  :group 'org)

;;;; org-capture

(defvar pws-org--capture-coach-person-history nil)

(declare-function message-fetch-field "message" (header &optional first))
(declare-function notmuch-show-get-header "notmuch-show")

(defun pws-org--capture-coach-person-message-from ()
  "Return default value for `pws-org--capture-coach-person-prompt'."
  (when-let* ((from (cond
                     ((derived-mode-p 'message-mode)
                      (message-fetch-field "To"))
                     ((derived-mode-p 'notmuch-show-mode)
                      (notmuch-show-get-header :From)))))
    (string-clean-whitespace (car (split-string from "<")))))

(defun pws-org--capture-coach-person-message-from-and-subject ()
  "Return default value for `pws-org--capture-coach-person-prompt'."
  (cond
   ((derived-mode-p 'message-mode)
    (message-fetch-field "Subject"))
   ((derived-mode-p 'notmuch-show-mode)
    (notmuch-show-get-header :Subject))))

(defun pws-org--capture-coach-person-prompt ()
  "Prompt for person for use in `pws-org-capture-coach'."
  (completing-read "Person to coach: "
                   pws-org--capture-coach-person-history
                   nil nil nil
                   'pws-org--capture-coach-person-history
                   (pws-org--capture-coach-person-message-from)))

(defvar pws-org--capture-coach-description-history nil)

(defun pws-org--capture-coach-description-prompt ()
  "Prompt for description in `pws-org-capture-coach'."
  (read-string "Description: "
               nil
               'pws-org--capture-coach-description-history
               (pws-org--capture-coach-person-message-from-and-subject)))

(defun pws-org--capture-coach-date-prompt-range ()
  "Prompt for Org date and return it as a +1h range.
For use in `pws-org-capture-coach'."
  (let ((date (org-read-date :with-time)))
    ;; We cannot use this here, unfortunately, as the Org agenda
    ;; interprets it both as a deadline and an event with the date
    ;; range.
    ;;
    ;; (format "DEADLINE: <%s>--<%s>\n" date
    (format "<%s>--<%s>\n" date
            (org-read-date
             :with-time nil "++1h" nil
             (org-encode-time (org-parse-time-string date))))))

(defun pws-org-capture-coach ()
  "Contents of an Org capture template for my coaching lessons."
  (let ((identifier (format-time-string "%Y%m%dT%H%M%S")))
    (format "* COACH %s %s :lesson:
DEADLINE: %%^T
:PROPERTIES:
:CAPTURED: %%U
:CUSTOM_ID: h:%s
:APPT_WARNTIME: 20
:END:

%%a%%?"
            (pws-org--capture-coach-person-prompt)
            (pws-org--capture-coach-description-prompt)
            identifier
            identifier)))

(defun pws-org-capture-coach-clock ()
  "Contents of an Org capture for my clocked coaching services."
  (format "* COACH %s %s :service:
:PROPERTIES:
:CAPTURED: %%U
:CUSTOM_ID: h:%s
:END:

%%a%%?"
          (pws-org--capture-coach-person-prompt)
          (pws-org--capture-coach-description-prompt)
          (format-time-string "%Y%m%dT%H%M%S")))

(declare-function cl-letf "cl-lib")

;; Adapted from source: <https://stackoverflow.com/a/54251825>.
;;
;; Thanks to Juanjo Presa (@uningan on GitHub) for discovering that the
;; original version was causing an error in `org-roam'.  I then figure
;; we were missing the `&rest':
;; <https://github.com/org-roam/org-roam/issues/2142#issuecomment-1100718373>.
(defun pws-org--capture-no-delete-windows (&rest args)
  "Apply ARGS while ignoring `delete-other-windows'."
  (cl-letf (((symbol-function 'delete-other-windows) 'ignore))
    (apply args)))

;; Same source as above
(advice-add 'org-capture-place-template :around 'pws-org--capture-no-delete-windows)
(advice-add 'org-add-log-note :around 'pws-org--capture-no-delete-windows)

;;;;; Custom function to select a project to add to

(defun pws-org--get-outline (&optional file)
  "Return `outline-regexp' headings and line numbers of current file or FILE."
  (with-current-buffer (find-file-noselect file)
    (let ((outline-regexp (format "^\\(?:%s\\)" (or (bound-and-true-p outline-regexp) "[*\^L]+")))
          candidates)
      (save-excursion
        (goto-char (point-min))
        (while (if (bound-and-true-p outline-search-function)
                   (funcall outline-search-function)
                 (re-search-forward outline-regexp nil t))
          (push
           ;; NOTE 2024-11-24: The -5 (minimum width) is a sufficiently high number to keep the
           ;; alignment consistent in most cases.  Larger files will simply shift the heading text
           ;; in minibuffer, but this is not an issue anymore.
           (format "%-5s\t%s"
                   (line-number-at-pos (point))
                   (buffer-substring-no-properties (line-beginning-position) (line-end-position)))
           candidates)
          (goto-char (1+ (line-end-position)))))
      (if candidates
          (nreverse candidates)
        (user-error "No outline")))))

(defvar pws-org-outline-history nil
  "Minibuffer history for `pws-org-outline-prompt'.")

(defun pws-org-outline-prompt (&optional file)
  "Prompt for outline among headings retrieved by `pws-org--get-outline'.
With optional FILE use the outline of it, otherwise use that of
the current file."
  (let ((current-file (or file buffer-file-name))
        (default (car pws-org-outline-history)))
    (completing-read
     (format-prompt
      (format "Select heading inside `%s': "
              (propertize (file-name-nondirectory current-file) 'face 'error))
      default)
     (pws-common-completion-table-no-sort 'imenu (pws-org--get-outline current-file))
     nil :require-match nil 'pws-org-outline-history default)))

(defvar pws-org-file-history nil
  "Minibuffer history of `pws-org-file-prompt'.")

(defun pws-org--not-useful-p (file)
  "Return non-nil if FILE is not a useful Org file for `org-capture'."
  (or (string-match-p "\\.org_archive\\'" file)
      (backup-file-name-p file)
      (not (string-match-p "\\.org\\'" file))))

(defun pws-org-file-prompt ()
  "Select a file in the `org-directory'."
  (if-let* ((dir org-directory)
            (files (directory-files-recursively org-directory ".*" nil))
            (files (seq-remove #'pws-org--not-useful-p files)))
      (let ((default (car pws-org-file-history)))
        (completing-read
         (format-prompt "Select file" default)
         (pws-common-completion-table 'file files)
         nil :require-match nil 'pws-org-file-history default))
    (user-error "There are no files in the `org-directory'")))

;;;###autoload
(defun pws-org-select-heading-in-file ()
  "Like `pws-org-select-project' but specifically for `org-capture'."
  (declare (interactive-only t))
  (interactive)
  (pcase-let* ((file (pws-org-file-prompt))
               (line-with-heading (pws-org-outline-prompt file))
               (`(,line ,text) (split-string line-with-heading "\t"))
               (line (string-to-number line)))
    ;; NOTE 2024-11-24: `with-current-buffer' does not work with `org-capture'.
    (find-file file)
    (goto-char (point-min))
    (forward-line (1- line))))

(defalias 'pws-org-goto-heading-in-file 'pws-org-select-heading-in-file
 "Alias for `pws-org-select-heading-in-file'.")

;;;; Org clock report

(defvar pws-org-clock--template-with-effort
  "#+BEGIN: clocktable :formula % :properties (\"Effort\") :timestamp t :sort (1 . ?a) :link t :scope nil :hidefiles t :maxlevel 8 :stepskip0 t
,#+END:"
  "Clock table with effort estimate column to use for custom clock reports.")

(defvar pws-org-clock--template-no-effort
  "#+BEGIN: clocktable :formula % :timestamp t :sort (1 . ?a) :link nil :scope nil :hidefiles t :maxlevel 8 :stepskip0 t
,#+END:"
  "Clock table to use for custom clock reports.")

(defvar pws-org-clock--ranges
  '( today yesterday thisweek lastweek thismonth
     lastmonth thisyear lastyear untilnow)
  "Time ranges of my interest for clock reports.")

(defvar pws-org-clock--report-range-history nil
  "Minibuffer history for `pws-org-clock--report-range-prompt'.")

(defun pws-org-clock--report-range-prompt ()
  "Prompt for a clock table range among `pws-org-clock--ranges'."
  (let ((default (car pws-org-clock--report-range-history)))
    (completing-read
     (format-prompt "Select a time range for the clock" default)
     pws-org-clock--ranges nil :require-match nil 'pws-org-clock--report-range-history
     default)))

(defun pws-org-clock--get-report (scope)
  "Produce clock report with current file SCOPE and return its buffer.
SCOPE is a symbol of either `file' or `subtree'.  If the former, then
use the entire file's contents.  Else use those of the current subtree."
  (let ((buffer (get-buffer-create "*pws-org-custom-clock-report*")))
    (save-restriction
      (unwind-protect
          (progn
            (pcase scope
              ('file nil)
              ('subtree (org-narrow-to-subtree))
              (_ (error "The scope `%s' is unknown" scope)))
            (let ((contents (buffer-substring (point-min) (point-max))))
              (with-current-buffer buffer
                (erase-buffer)
                (org-mode)
                (save-excursion
                  (insert (format "%s\n\n" pws-org-clock--template-with-effort))
                  (insert contents))
                (save-excursion
                  (let ((range (pws-org-clock--report-range-prompt)))
                    (goto-char (line-end-position))
                    (insert (concat " :block " range))))
                (org-dblock-update))))
        (widen)))
    buffer))

;;;###autoload
(defun pws-org-clock-report-current-subtree-or-file (&optional whole-buffer)
  "Produce a clock report in a new buffer for the subtree at point.
With optional WHOLE-BUFFER as a non-nil value, operate on the entire file.
When called interactively WHOLE-BUFFER is a prefix argument."
  (interactive "P")
  (when-let* ((buffer (pws-org-clock--get-report (if whole-buffer 'file 'subtree))))
    (pop-to-buffer buffer)))

;;;###autoload
(defun pws-org-clock-select-heading-and-clock-report ()
  "Select a heading in a file and do a clock report for it in a new buffer."
  (interactive)
  (call-interactively 'pws-org-select-heading-in-file)
  (call-interactively 'pws-org-clock-report-current-subtree-or-file))

;;;;; Coaching-related Org custom clocking

;; TODO 2024-12-15: This sort of thing must exist in Org, but I did
;; not find it.
(defun pws-org--timestamp-to-time (string)
  "Return time object of STRING timestamp."
  (org-timestamp-to-time (org-timestamp-from-string string)))

(defun pws-org-coach--get-entries (todo-keyword string since)
  "Get Org entries matching TODO-KEYWORD followed by STRING in the heading.
Limit entries to those whole deadline/scheduled is equal or greater to
SINCE date.

Each entry is a plist of :heading, :contents, :started, :closed."
  (or (delq nil
            (org-map-entries
             (lambda ()
               (when-let* ((case-fold-search t)
                           (started (pws-org--timestamp-to-time (or (org-entry-get nil "DEADLINE") (org-entry-get nil "SCHEDULED"))))
                           (closed (pws-org--timestamp-to-time (org-entry-get nil "CLOSED")))
                           ((re-search-forward (format "\\<%s\\>.*\\<%s\\>" todo-keyword string) (line-end-position) t 1))
                           ((org-time-less-p since started)))
                 (list
                  :heading (org-get-heading :no-tags :no-todo :no-priority :no-comment)
                  :contents (org-get-entry)
                  :started started
                  :closed closed)))))
      (user-error "No entries with heading matching `\\<%s\\>.*\\<%s\\>'" todo-keyword string)))

(defvar pws-org-coach--name-history nil
  "Minibuffer history of `pws-org-coach--name-prompt'.")

(defun pws-org-coach--name-prompt ()
  "Prompt for name of person."
  (let ((default (car pws-org-coach--name-history)))
    (read-string
     (format-prompt "Name of person" default)
     nil 'pws-org-coach--name-history default)))

;;;###autoload
(defun pws-org-coach-report (name since)
  "Produce clock report for coaching with person of NAME.
SINCE is the date (of time 00:00) to count from until now."
  (interactive
   (list
    (pws-org-coach--name-prompt)
    (format "[%s]" (org-read-date))))
  (if-let* ((since-object (pws-org--timestamp-to-time since))
            (entries (pws-org-coach--get-entries "done" name since-object))
            (buffer (get-buffer-create "*pws-org-coach-entries*")))
      (with-current-buffer (pop-to-buffer buffer)
        (erase-buffer)
        (org-mode)
        (dolist (entry entries)
          (insert (format "* %s\n%s\n\n" (plist-get entry :heading) (plist-get entry :contents)))
          (org-clock-in nil (plist-get entry :started))
          (org-clock-out nil t (plist-get entry :closed)))
        (goto-char (point-min))
        (save-excursion
          (insert (format "%s\n\n" pws-org-clock--template-no-effort)))
        (save-excursion
          (goto-char (line-end-position))
          (insert (format " :tstart %S" since)))
        (org-dblock-update))
    (user-error "No entries for name `%s'" name)))

;;;; org-agenda

(declare-function calendar-day-name "calendar")
(declare-function calendar-day-of-week "calendar")
(declare-function calendar-month-name "calendar")
(declare-function org-days-to-iso-week "org")
(declare-function calendar-absolute-from-gregorian "calendar")

(defvar org-agenda-format-date)

;;;###autoload
(defun pws-org-agenda-format-date-aligned (date)
  "Format a DATE string for display in the daily/weekly agenda.
This function makes sure that dates are aligned for easy reading.

Slightly tweaked version of `org-agenda-format-date-aligned' that
produces dates with a fixed length."
  (require 'cal-iso)
  (let* ((dayname (calendar-day-name date t))
         (day (cadr date))
         (day-of-week (calendar-day-of-week date))
         (month (car date))
         (monthname (calendar-month-name month t))
         (year (nth 2 date))
         (iso-week (org-days-to-iso-week
                    (calendar-absolute-from-gregorian date)))
         ;; (weekyear (cond ((and (= month 1) (>= iso-week 52))
         ;;                  (1- year))
         ;;                 ((and (= month 12) (<= iso-week 1))
         ;;                  (1+ year))
         ;;                 (t year)))
         (weekstring (if (= day-of-week 1)
                         (format " (W%02d)" iso-week)
                       "")))
    (format "%s %2d %s %4d%s"
            dayname day monthname year weekstring)))

(defvar org-priority-highest)

(defun pws-org-agenda-include-priority-no-timestamp ()
  "Return nil if heading has a priority but no timestamp.
Otherwise, return the buffer position from where the search should
continue, per `org-agenda-skip-function'."
  (let ((point (point)))
    (if (and (eq (nth 3 (org-heading-components)) ?A)
             (not (org-get-deadline-time point))
             (not (org-get-scheduled-time point)))
        nil
      (line-beginning-position 2))))

(defvar pws-org-custom-daily-agenda
  ;; NOTE 2021-12-08: Specifying a match like the following does not
  ;; work.
  ;;
  ;; tags-todo "+PRIORITY=\"A\""
  ;;
  ;; So we match everything and then skip entries with
  ;; `org-agenda-skip-function'.
  `((tags-todo "*"
               ((org-agenda-overriding-header "Important tasks without a date\n")
                ;; NOTE 2024-10-31: Those used to work, but now the
                ;; query for the timestamp is ignored.  I thus wrote
                ;; `pws-org-agenda-include-priority-no-timestamp'.
                ;;
                ;; (org-agenda-skip-function '(org-agenda-skip-subtree-if nil '(timestamp)))
                ;; (org-agenda-skip-function
                ;;  `(org-agenda-skip-entry-if
                ;;    'notregexp ,(format "\\[#%s\\]" (char-to-string org-priority-highest))))
                (org-agenda-skip-function #'pws-org-agenda-include-priority-no-timestamp)
                (org-agenda-block-separator nil)))
    (agenda "" ((org-agenda-overriding-header "\nPending scheduled tasks")
                (org-agenda-time-grid nil)
                (org-agenda-start-on-weekday nil)
                (org-agenda-span 1)
                (org-agenda-show-all-dates nil)
                (org-scheduled-past-days 365)
                ;; Excludes today's scheduled items
                (org-scheduled-delay-days 1)
                (org-agenda-block-separator nil)
                (org-agenda-entry-types '(:scheduled))
                (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                (org-agenda-skip-function '(org-agenda-skip-entry-if 'regexp "ROUTINE"))
                (org-agenda-day-face-function (lambda (date) 'org-agenda-date))
                (org-agenda-format-date "")))
    (agenda "" ((org-agenda-overriding-header "\nToday's agenda\n")
                (org-agenda-span 1)
                (org-deadline-warning-days 0)
                (org-agenda-block-separator nil)
                (org-scheduled-past-days 0)
                (org-agenda-skip-function '(org-agenda-skip-entry-if 'regexp "ROUTINE"))
                ;; We don't need the `org-agenda-date-today'
                ;; highlight because that only has a practical
                ;; utility in multi-day views.
                (org-agenda-day-face-function (lambda (date) 'org-agenda-date))
                (org-agenda-format-date "%A %-e %B %Y")))
    ;; (agenda "" ((org-agenda-overriding-header "\nRoutine")
    ;;             (org-agenda-time-grid nil)
    ;;             (org-agenda-start-on-weekday nil)
    ;;             (org-agenda-span 1)
    ;;             (org-agenda-show-all-dates nil)
    ;;             (org-scheduled-past-days 365)
    ;;             ;; Excludes today's scheduled items
    ;;             (org-scheduled-delay-days 1)
    ;;             (org-agenda-block-separator nil)
    ;;             (org-agenda-entry-types '(:scheduled))
    ;;             (org-agenda-skip-function '(org-agenda-skip-entry-if 'notregexp "ROUTINE"))
    ;;             (org-agenda-day-face-function (lambda (date) 'org-agenda-date))
    ;;             (org-agenda-format-date "")))
    (agenda "" ((org-agenda-overriding-header "\nNext three days\n")
                (org-agenda-start-on-weekday nil)
                (org-agenda-start-day nil)
                (org-agenda-start-day "+1d")
                (org-agenda-span 3)
                (org-deadline-warning-days 0)
                (org-agenda-block-separator nil)
                (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))))
    (agenda "" ((org-agenda-overriding-header "\nUpcoming deadlines (+14d)\n")
                (org-agenda-time-grid nil)
                (org-agenda-start-on-weekday nil)
                ;; We don't want to replicate the previous section's
                ;; three days, so we start counting from the day after.
                (org-agenda-start-day "+4d")
                (org-agenda-span 14)
                (org-agenda-show-all-dates nil)
                (org-deadline-warning-days 0)
                (org-agenda-block-separator nil)
                (org-agenda-entry-types '(:deadline))
                (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done)))))
  "Custom agenda for use in `org-agenda-custom-commands'.")

;;;;; agenda appointments

(defvar pws-org-agenda-after-edit-hook nil
  "Hook that runs after select Org commands.
To be used with `advice-add'.")

(defun pws-org--agenda-after-edit (&rest _)
  "Run `pws-org-agenda-after-edit-hook'."
  (run-hooks 'pws-org-agenda-after-edit-hook))

(defvar pws-org-after-deadline-or-schedule-hook nil
  "Hook that runs after `org--deadline-or-schedule'.
To be used with `advice-add'.")

(defvar pws-org--appt-agenda-commands
  '( org-agenda-archive org-agenda-deadline org-agenda-schedule
     org-agenda-todo org-archive-subtree)
  "List of commands that run `pws-org-agenda-after-edit-hook'.")

(dolist (fn pws-org--appt-agenda-commands)
  (advice-add fn :after #'pws-org--agenda-after-edit))

(defun pws-org--after-deadline-or-schedule (&rest _)
  "Run `pws-org-after-deadline-or-schedule-hook'."
  (run-hooks 'pws-org-after-deadline-or-schedule-hook))

(defun pws-org-org-agenda-to-appt ()
  "Make `org-agenda-to-appt' always refresh appointment list."
  (org-agenda-to-appt :refresh))

(dolist (hook '(org-capture-after-finalize-hook
                org-after-todo-state-change-hook
                org-agenda-after-show-hook
                pws-org-agenda-after-edit-hook))
  (add-hook hook #'pws-org-org-agenda-to-appt))

(declare-function org--deadline-or-schedule "org" (arg type time))

(advice-add #'org--deadline-or-schedule :after #'pws-org--after-deadline-or-schedule)

(add-hook 'pws-org-after-deadline-or-schedule-hook #'pws-org-org-agenda-to-appt)

;;;; org-export

(declare-function org-html-export-as-html "org")
(declare-function org-texinfo-export-to-info "org")

;;;###autoload
(defun pws-org-ox-html ()
  "Streamline HTML export."
  (interactive)
  (org-html-export-as-html nil nil nil t nil))

;;;###autoload
(defun pws-org-ox-texinfo ()
  "Streamline Info export."
  (interactive)
  (org-texinfo-export-to-info))

;;;; org-id

(declare-function org-id-add-location "org")
(declare-function org-with-point-at "org")
(declare-function org-entry-get "org")
(declare-function org-id-new "org")
(declare-function org-entry-put "org")

;; Original idea:
;; <https://writequit.org/articles/emacs-org-mode-generate-ids.html>.
(defun pws-org--id-get ()
  "Get the CUSTOM_ID of the current entry.
If the entry already has a CUSTOM_ID, return it as-is, else
create a new one."
  (let* ((pos (point))
         (id (org-entry-get pos "CUSTOM_ID")))
    (or (and id (stringp id) (string-match-p "\\S-" id))
        (and (setq id (org-id-new "h")) (org-entry-put pos "CUSTOM_ID" id)))
    id))

(defun pws-org--heading-to-id ()
  "Convert current heading text to an ID for CUSTOM_ID purposes."
  (thread-last
    (org-get-heading :no-tags :no-todo :no-priority :no-comment)
    (replace-regexp-in-string "[][{}!@#$%^&*()+'\"?,.\|;:~`‘’“”/=]*" "")
    (replace-regexp-in-string "\s" "-")
    (string-trim)
    (downcase)
    (concat "h:")))

(defun pws-org--id-get-readable ()
  "Like `pws-org--id-get' but use the heading wording to create and ID."
  (let* ((pos (point))
         (id (org-entry-get pos "CUSTOM_ID")))
    (or (and id (stringp id) (string-match-p "\\S-" id))
        (and (setq id (pws-org--heading-to-id))
             (org-entry-put pos "CUSTOM_ID" id)))
    id))

(declare-function org-map-entries "org")

;;;###autoload
(defun pws-org-id-headlines ()
  "Add missing CUSTOM_ID to all headlines in current file."
  (interactive)
  (org-map-entries (lambda () (pws-org--id-get))))

;;;###autoload
(defun pws-org-id-headlines-readable ()
  "Like `pws-org-id-headlines' but with readable IDs.
A readable identifier is one derived from the text of the heading.  In
theory, this may not be unique."
  (interactive)
  (org-map-entries (lambda () (pws-org--id-get-readable))))

;;;###autoload
(defun pws-org-id-headline (&optional readable)
  "Add missing CUSTOM_ID to headline at point.
With optional prefix argument READABLE get a readable identifier derived
from the heading text instead of a UUID."
  (interactive "P")
  (funcall (if readable 'pws-org--id-get-readable 'pws-org--id-get)))

;;;###autoload
(defun pws-org-get-dotemacs-link ()
  "Get URL to current heading in my dotemacs file."
  (declare (interactive-only t))
  (interactive)
  (if (and (derived-mode-p 'org-mode)
           (string-match-p "pws-emacs\\.org\\'" buffer-file-name))
      (if-let* ((id (org-entry-get (point) "CUSTOM_ID"))
                (url (concat "https://protesilaos.com/emacs/dotemacs#" id)))
          (progn
            (kill-new url)
            (message "Copied %s" (propertize url 'face 'success)))
        (error "No CUSTOM_ID for the current entry"))
    (user-error "You are not in the right file")))

(provide 'pws-org)
;;; pws-org.el ends here
#+end_src

